# hacky hacky hacky -- generated by src/spec_gen.rb, then hand-tweaked

# this spec is only looking to check each ts_ call doesn't raise or crash and 
# returns the right type, given acceptable args

describe "parser_spec.rb" do
	before do
    @pars = TreeSitterFFI.parser
		@json = TreeSitterFFI.parser_json
		@pars.set_language(@json).should == true
		@input = "[1, null]"
		@tree = @pars.parse_string(nil, @input, @input.length)
	end
    
	it "set_language(Language) # => :bool" do
		ret = @pars.set_language(@json)
		[true, false].include?(ret).should == true
	end

	it "language() # => Language" do
		ret = @pars.language()
		ret.should_not == nil
		ret.is_a?(TreeSitterFFI::Language).should == true
	end

	it "set_included_ranges(Range|Array) # => :bool" do
		ranges = TreeSitterFFI::Range.new
		ret = @pars.set_included_ranges(ranges)
		[true, false].include?(ret).should == true
	end

	it "included_ranges() # => Array" do
		ret = @pars.included_ranges()
		ret.should_not == nil
		ret.is_a?(Array).should == true
	end

# ret is array of Range, arg_1 is pointer to array len.
# 	it "included_ranges(Integer) # => Pointer" do
# 		arg_0 = FFI::MemoryPointer.new(:uint32, 1)
# 		ret = @pars.included_ranges(arg_0)
# 		ret.should_not == nil
# 		ret.is_a?(FFI::Pointer).should == true
# 		len = arg_0.get(:uint32, 0)
# 		len.should_not == nil
# 		len.is_a?(Integer).should == true
# 	end

	it "parse(Tree, Input) # => Tree" do
		:parse.should_not == :FIXME # not impl
# 		ret = @pars.parse(arg_0, arg_1)
# 		ret.should_not == nil
# 		ret.is_a?(TreeSitterFFI::Tree).should == true
	end

	it "parse_string(Tree, String, Integer) # => Tree" do
		ret = @pars.parse_string(@tree, "blurg", 5)
		ret.should_not == nil
		ret.is_a?(TreeSitterFFI::Tree).should == true
	end

	it "parse_string_encoding(Tree, String, Integer, EnumInputEncoding) # => Tree" do
		ret = @pars.parse_string_encoding(@tree, "blurg", 5, :utf8)
		ret.should_not == nil
		ret.is_a?(TreeSitterFFI::Tree).should == true
	end

	it "reset() # => :void" do
		ret = @pars.reset()
		# ret void
	end

	it "set_timeout_micros(Integer) # => :void" do
		ret = @pars.set_timeout_micros(2000)
		# ret void
	end

	it "timeout_micros() # => Integer" do
		ret = @pars.timeout_micros()
		ret.should_not == nil
		ret.is_a?(Integer).should == true
	end

	it "set_cancellation_flag(Pointer) # => :void" do
		arg_0 = FFI::MemoryPointer.new(:pointer, 1) # :size_p is Pointer
		ret = @pars.set_cancellation_flag(arg_0)
		# ret void
	end

	it "cancellation_flag() # => Pointer" do
		ret = @pars.cancellation_flag()
# 		ret.should_not == nil # nil return permitted!!!
		ret.is_a?(FFI::Pointer).should == true if ret
	end

	it "set_logger(Logger) # => :void" do
		:set_logger.should_not == :FIXME # not impl
# 		ret = @pars.set_logger(arg_0)
# 		# ret void
	end

	it "logger() # => Logger" do
		:logger.should_not == :FIXME # not impl
# 		ret = @pars.logger()
# 		ret.should_not == nil
# 		ret.is_a?(TreeSitterFFI::Logger).should == true
	end

	it "print_dot_graphs(Integer) # => :void" do
		ret = @pars.print_dot_graphs(2)
		# ret void
	end


end
