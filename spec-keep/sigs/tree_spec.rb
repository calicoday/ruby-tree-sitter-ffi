# hacky hacky hacky -- generated by src/spec_gen.rb, then hand-tweaked

# this spec is only looking to check each ts_ call doesn't raise or crash and 
# returns the right type, given acceptable args

describe "tree_spec.rb" do
	before do
    @pars = TreeSitterFFI.parser
		json = TreeSitterFFI.parser_json
		@pars.set_language(json).should == true
		@input = "[1, null]"
		@tree = @pars.parse_string(nil, @input, @input.length)
		@root_node = @tree.root_node
		@root_node = @tree.root_node
# 		@array_node = @root_node.named_child(0)
		@tree_cursor = TreeSitterFFI.ts_tree_cursor_new(@root_node) #crashes!!! FIXME!!!
	end
    
	it "copy() # => Tree" do
		ret = @tree.copy()
		ret.should_not == nil
		ret.is_a?(TreeSitterFFI::Tree).should == true
	end

	it "root_node() # => Node" do
		ret = @tree.root_node()
		ret.should_not == nil
		ret.is_a?(TreeSitterFFI::Node).should == true
	end

	it "language() # => Language" do
		ret = @tree.language()
		ret.should_not == nil
		ret.is_a?(TreeSitterFFI::Language).should == true
	end

	# need to try this with more useful InputEdit values
	it "edit(InputEdit) # => :void" do
		ret = @tree.edit(TreeSitterFFI::InputEdit.new)
		# ret void
	end

	it "get_changed_ranges(Tree, Integer) # => Pointer" do
		# compare @tree to itself
		arg_1 = @tree
		arg_2 = FFI::MemoryPointer.new(:uint32, 1)
		ret = @tree.get_changed_ranges(arg_1, arg_2)
# 		ret.should_not == nil # nil is permitted (if no diff, len == 0)
		ret.is_a?(FFI::Pointer).should == true
		len = arg_2.get(:uint32, 0)
		len.should_not == nil
		len.is_a?(Integer).should == true
	end

	# come back to FILE pointer
	it "print_dot_graph(Pointer) # => :void" do
		:print_dot_graph.should_not == :FIXME
# 		ret = @tree.print_dot_graph(arg_1)
# 		# ret void
	end

### TreeCursors 

	it "reset(Node) # => :void" do
		# reset to same root_node
		arg_1 = @root_node
		ret = @tree_cursor.reset(arg_1)
		# ret void
	end

	it "current_node() # => Node" do
		ret = @tree_cursor.current_node()
		ret.should_not == nil
		ret.is_a?(TreeSitterFFI::Node).should == true
	end

	it "current_field_name() # => String" do
		ret = @tree_cursor.current_field_name()
# 		ret.should_not == nil # nil is permitted 
		ret.is_a?(String).should == true if ret
	end

	it "current_field_id() # => Integer" do
		ret = @tree_cursor.current_field_id()
		ret.should_not == nil
		ret.is_a?(Integer).should == true
	end

	it "goto_parent() # => :bool" do
		ret = @tree_cursor.goto_parent()
		[true, false].include?(ret).should == true
	end

	it "goto_next_sibling() # => :bool" do
		ret = @tree_cursor.goto_next_sibling()
		[true, false].include?(ret).should == true
	end

	it "goto_first_child() # => :bool" do
		ret = @tree_cursor.goto_first_child()
		[true, false].include?(ret).should == true
	end

	it "goto_first_child_for_byte(Integer) # => Integer" do
		ret = @tree_cursor.goto_first_child_for_byte(5)
		ret.should_not == nil
		ret.is_a?(Integer).should == true
	end

	it "goto_first_child_for_point(Point) # => Integer" do
		ret = @tree_cursor.goto_first_child_for_point(TreeSitterFFI::Point.new)
		ret.should_not == nil
		ret.is_a?(Integer).should == true
	end

	it "copy() # => TreeCursor" do
		ret = @tree_cursor.copy()
		ret.should_not == nil
		ret.is_a?(TreeSitterFFI::TreeCursor).should == true
	end

end
