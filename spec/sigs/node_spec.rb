# hacky hacky hacky -- generated by src/spec_gen.rb, then hand-tweaked

# this spec is only looking to check each ts_ call doesn't raise or crash and 
# returns the right type, given acceptable args

describe "node_spec.rb" do
	before do
    @pars = TreeSitterFFI.parser
		json = TreeSitterFFI.parser_json
		@pars.set_language(json).should == true
		@input = "[1, null]"
		@tree = @pars.parse_string(nil, @input, @input.length)
		@root_node = @tree.root_node
		@array_node = @root_node.named_child(0)
		@number_node = @array_node.named_child(0)
	end
    
	it "type() # => String" do
		ret = @number_node.type()
		ret.should_not == nil
		ret.is_a?(String).should == true
	end

	it "symbol() # => Integer" do
		ret = @number_node.symbol()
		ret.should_not == nil
		ret.is_a?(Integer).should == true
	end

	it "start_byte() # => Integer" do
		ret = @number_node.start_byte()
		ret.should_not == nil
		ret.is_a?(Integer).should == true
	end

	it "start_point() # => Point" do
		ret = @number_node.start_point()
		ret.should_not == nil
		ret.is_a?(TreeSitterFFI::Point).should == true
	end

	it "end_byte() # => Integer" do
		ret = @number_node.end_byte()
		ret.should_not == nil
		ret.is_a?(Integer).should == true
	end

	it "end_point() # => Point" do
		ret = @number_node.end_point()
		ret.should_not == nil
		ret.is_a?(TreeSitterFFI::Point).should == true
	end

	# do better!!!
	it "string() # => Array" do
		ret = @number_node.string()
		ret.should_not == nil
		ret.is_a?(String).should == true # :strptr is [String, FFI::Pointer]
		# nope, we're ruby now
# 		ret.is_a?(Array).should == true # :strptr is [String, FFI::Pointer]
	end

	it "is_null() # => :bool" do
		ret = @number_node.is_null()
		[true, false].include?(ret).should == true
	end

	it "is_named() # => :bool" do
		ret = @number_node.is_named()
		[true, false].include?(ret).should == true
	end

	it "is_missing() # => :bool" do
		ret = @number_node.is_missing()
		[true, false].include?(ret).should == true
	end

	it "is_extra() # => :bool" do
		ret = @number_node.is_extra()
		[true, false].include?(ret).should == true
	end

	it "has_changes() # => :bool" do
		ret = @number_node.has_changes()
		[true, false].include?(ret).should == true
	end

	it "has_error() # => :bool" do
		ret = @number_node.has_error()
		[true, false].include?(ret).should == true
	end

	it "parent() # => Node" do
		ret = @number_node.parent()
		ret.should_not == nil
		ret.is_a?(TreeSitterFFI::Node).should == true
	end

	# not sure yet whether we can use just any node args, so try @array_node here for now
	it "child(Integer) # => Node" do
		ret = @array_node.child(3)
		ret.should_not == nil
		ret.is_a?(TreeSitterFFI::Node).should == true
	end

	it "field_name_for_child(Integer) # => String" do
		ret = @array_node.field_name_for_child(3)
# 		ret.should_not == nil # nil return permitted!!!
		ret.is_a?(String).should == true if ret
	end

	it "child_count() # => Integer" do
		ret = @array_node.child_count()
		ret.should_not == nil
		ret.is_a?(Integer).should == true
	end

	it "named_child(Integer) # => Node" do
		ret = @array_node.named_child(0)
		ret.should_not == nil
		ret.is_a?(TreeSitterFFI::Node).should == true
	end

	it "named_child_count() # => Integer" do
		ret = @array_node.named_child_count()
		ret.should_not == nil
		ret.is_a?(Integer).should == true
	end

	# come back to these two Field map ones:
	it "child_by_field_name(String,) # => Node" do
		ret = @number_node.child_by_field_name("blurg")
# 		ret.should_not == nil # nil return permitted!!! ie, no_node
		ret.is_a?(TreeSitterFFI::Node).should == true
	end

	it "child_by_field_id(Integer) # => Node" do
		ret = @number_node.child_by_field_id(2)
# 		ret.should_not == nil # nil return permitted!!! ie, no_node
		ret.is_a?(TreeSitterFFI::Node).should == true
	end

	it "next_sibling() # => Node" do
		ret = @number_node.next_sibling()
		ret.should_not == nil
		ret.is_a?(TreeSitterFFI::Node).should == true
	end

	it "prev_sibling() # => Node" do
		ret = @number_node.prev_sibling()
		ret.should_not == nil
		ret.is_a?(TreeSitterFFI::Node).should == true
	end

	it "next_named_sibling() # => Node" do
		ret = @number_node.next_named_sibling()
		ret.should_not == nil
		ret.is_a?(TreeSitterFFI::Node).should == true
	end

	it "prev_named_sibling() # => Node" do
		ret = @number_node.prev_named_sibling()
# 		ret.should_not == nil # nil return permitted!!! ie, no_node
		ret.is_a?(TreeSitterFFI::Node).should == true
	end

	# again array_node, nec???
	it "first_child_for_byte(Integer) # => Node" do
		ret = @array_node.first_child_for_byte(5)
		ret.should_not == nil
		ret.is_a?(TreeSitterFFI::Node).should == true
	end

	it "first_named_child_for_byte(Integer) # => Node" do
		ret = @array_node.first_named_child_for_byte(1)
		ret.should_not == nil
		ret.is_a?(TreeSitterFFI::Node).should == true
	end

	it "descendant_for_byte_range(Integer, Integer) # => Node" do
		ret = @array_node.descendant_for_byte_range(2, 3)
		ret.should_not == nil
		ret.is_a?(TreeSitterFFI::Node).should == true
	end

	it "descendant_for_point_range(Point, Point) # => Node" do
		ret = @array_node.descendant_for_point_range(TreeSitterFFI::Point.new, 
			TreeSitterFFI::Point.new)
		ret.should_not == nil
		ret.is_a?(TreeSitterFFI::Node).should == true
	end

	it "named_descendant_for_byte_range(Integer, Integer) # => Node" do
		ret = @number_node.named_descendant_for_byte_range(5, 7)
		ret.should_not == nil
		ret.is_a?(TreeSitterFFI::Node).should == true
	end

	it "named_descendant_for_point_range(Point, Point) # => Node" do
		ret = @number_node.named_descendant_for_point_range(TreeSitterFFI::Point.new, 
			TreeSitterFFI::Point.new)
		ret.should_not == nil
		ret.is_a?(TreeSitterFFI::Node).should == true
	end

	it "edit(InputEdit) # => :void" do
		ret = @number_node.edit(TreeSitterFFI::InputEdit.new)
		# ret void
	end

	it "eq(Node) # => :bool" do
		ret = @number_node.eq(TreeSitterFFI::Node.new)
		[true, false].include?(ret).should == true
	end


end
