# hacky hacky hacky -- generated by src/spec_gen.rb, then hand-tweaked

# this spec is only looking to check each ts_ call doesn't raise or crash and 
# returns the right type, given acceptable args

describe "query_spec.rb" do
	before do
    @pars = TreeSitterFFI.parser
		@json = TreeSitterFFI.parser_json
		@pars.set_language(@json).should == true
		@input = "[1, null]"
		@tree = @pars.parse_string(nil, @input, @input.length)
		@sexp = '(document (array (number) (null)))'
# 		arg_0 = FFI::MemoryPointer.new(:uint32, 1)
# 		ret = @pars.included_ranges(arg_0)
# 		len = arg_0.get(:uint32, 0)
		@err_offset_p = FFI::MemoryPointer.new(:uint32, 1)
		@err_type_p = FFI::MemoryPointer.new(:uint32, 1) # enum!!!
# 		@err_type_p = FFI::MemoryPointer.new(TreeSitterFFI::EnumQueryError, 1) # enum!!!
		@query = TreeSitterFFI.ts_query_new(@json, @sexp, @sexp.length, 
			@err_offset_p, @err_type_p)
# 		puts "err_offset: #{@err_offset_p.get(:uint32, 0)}"
# 		puts "err_type: #{@err_type_p.get(:uint32, 0)}"
		@query_cursor = TreeSitterFFI.ts_query_cursor_new()
		@root_node = @tree.root_node
	end
    
	it "pattern_count() # => Integer" do
		ret = @query.pattern_count()
		ret.should_not == nil
		ret.is_a?(Integer).should == true
	end

	it "capture_count() # => Integer" do
		ret = @query.capture_count()
		ret.should_not == nil
		ret.is_a?(Integer).should == true
	end

	it "string_count() # => Integer" do
		ret = @query.string_count()
		ret.should_not == nil
		ret.is_a?(Integer).should == true
	end

	it "start_byte_for_pattern(Integer) # => Integer" do
		ret = @query.start_byte_for_pattern(5)
		ret.should_not == nil
		ret.is_a?(Integer).should == true
	end

	it "predicates_for_pattern(Integer, Integer) # => QueryPredicateStep" do
		arg_1 = 5
		arg_2 = FFI::MemoryPointer.new(:uint32, 1)
		ret = @query.predicates_for_pattern(arg_1, arg_2)
		ret.should_not == nil
		ret.is_a?(TreeSitterFFI::QueryPredicateStep).should == true
		len = arg_2.get(:uint32, 0)
		len.should_not == nil
		len.is_a?(Integer).should == true
	end

	it "step_is_definite(Integer) # => :bool" do
		ret = @query.step_is_definite(5)
		[true, false].include?(ret).should == true
	end

	# don't know what are acceptable arg values!!!
	it "capture_name_for_id(Integer, Integer) # => String" do
		:capture_name_for_id.should_not == :FIXME
# 		ret = @query.capture_name_for_id(arg_1, arg_2)
# 		ret.should_not == nil
# 		ret.is_a?(String).should == true
	end

	# don't know what are acceptable arg values!!!
	it "string_value_for_id(Integer, Integer) # => String" do
		:string_value_for_id.should_not == :FIXME
# 		ret = @query.string_value_for_id(arg_1, arg_2)
# 		ret.should_not == nil
# 		ret.is_a?(String).should == true
	end

	it "disable_capture(String, Integer) # => :void" do
		ret = @query.disable_capture("blurg", 1)
		# ret void
	end

	it "disable_pattern(Integer) # => :void" do
		ret = @query.disable_pattern(1)
		# ret void
	end

### QueryCursor 

	it "exec(Query, Node) # => :void" do
		ret = @query_cursor.exec(@query, @root_node)
		# ret void
	end

	it "did_exceed_match_limit() # => :bool" do
		ret = @query_cursor.did_exceed_match_limit()
		[true, false].include?(ret).should == true
	end

	it "match_limit() # => Integer" do
		ret = @query_cursor.match_limit()
		ret.should_not == nil
		ret.is_a?(Integer).should == true
	end

	it "set_match_limit(Integer) # => :bool" do
		ret = @query_cursor.set_match_limit(12)
		[true, false].include?(ret).should == true
	end

	it "set_byte_range(Integer, Integer) # => :void" do
		ret = @query_cursor.set_byte_range(1, 5)
		# ret void
	end

	it "set_point_range(Point) # => :void" do
		ret = @query_cursor.set_point_range(TreeSitterFFI::Point.new)
		# ret void
	end

	# don't know what are acceptable arg values!!!
	it "next_match(QueryMatch) # => :bool" do
		:next_match.should_not == :FIXME
# 		ret = @query_cursor.next_match(arg_1)
# 		[true, false].include?(ret).should == true
	end

	it "remove_match(Integer) # => :void" do
		ret = @query_cursor.remove_match(5)
		# ret void
	end

	# don't know what are acceptable arg values!!!
	it "next_capture(QueryMatch, Integer) # => :bool" do
		:next_capture.should_not == :FIXME
# 		ret = @query_cursor.next_capture(arg_1, arg_2)
# 		[true, false].include?(ret).should == true
	end


end
