# Yo, cal: do not keep fussing over this one!!!

# spec_gen.rb is a throw-away, bootstrap script to generate blunt tests for each 
# function sig of the main boss classes (and their mod.ts_ equivalents).
# There is definitely a role for such a script but this is exactly the
# sort of thing better done with a proper language parser not regexps.
# To be continued.

# Re source code style, the script is not comment-aware. Do not put comments within 
# a wrap_attach() entry (eg when it's broken over several lines and you want to 
# note some particular arg) and any whole entries or wrap_attach() blocks 
# commented out will get picked up. Outside of wrap_attach(), everything is ignored.

# 	typedef :pointer, :blang
# 	typedef :strptr, :adoptstring
# 	typedef :uint16, :symbol
# 	typedef :uint16, :field_id
# 	typedef :pointer, :size_p

def chg_type(type)
	case type
	when /:u?int\d+/ then 'Integer'
	when ':bool', ':void' then type
	when ':string' then 'String'
	when /[A-Z][\w.]+/ then type.split('.').first
	# FFI typedefs
	when ':adoptstring', ':strptr' then 'Array' 
	when ':pointer', ':uint32_p', ':size_p', ':array_of_range', 
		':file_pointer', ':query_error_p'
		'Pointer'
	when ':symbol', ':field_id', ':file_descriptor' then 'Integer'
	else
		'WaitWhat'
	end
end

def qual_type(type)
	begin
		::Kernel.const_get(type)
	rescue
		# if type isn't recognized, assume it belongs to tree_sitter_ffi and qualify
		type = "TreeSitterFFI::#{type.to_s}"
	end
end

def mk_file(outdir, boss, &b)
	out_ts = File.open(outdir+"/ts_#{boss}_spec.rb", "w")
	out_ts << mk_descr_head("ts_#{boss}_spec.rb")
	out_rb = File.open(outdir+"/#{boss}_spec.rb", "w")
	out_rb << mk_descr_head("#{boss}_spec.rb")
	yield(out_ts, out_rb)
	out_ts << "\nend\n"
	out_ts.close
	out_rb << "\nend\n"
	out_rb.close
end

def mk_descr_head(label)
  expected_result = <<-INDENTED_HEREDOC
# hacky hacky hacky -- generated by src/gen/spec_gen.rb, then COPIED and hand-tweaked

# this spec is only looking to check each ts_ call doesn't raise or crash and 
# returns the right type, given acceptable args

describe "#{label}" do
	before do
	end
    
	INDENTED_HEREDOC
end

# def mk_it_base(label, name, argslist, &b)
# 	s = "\tit \"#{label}\" do\n"
# 	s += "\t\tret = #{name}(#{arglist})\n"
# 	s += yield(label, name, args)
# 	s += "\tend\n\n"
# end

def mk_arglist(boss, arg_count)
	((boss ? ["#{boss}_0"] : []) + (1...arg_count).map{|i| "arg_#{i}"}).join(', ')
end

def mk_it_base(label, name, boss, args, &b)
	s = "\tit \"#{label}\" do\n"
# 	arglist = args.length.times.map{|i| "arg_#{i}"}.join(', ')
	arglist = mk_arglist(boss, args.length)
	s += "\t\tret = #{name}(#{arglist})\n"
	s += yield(label, name, args)
	s += "\tend\n\n"
end

# def mk_it_base(label, name, args, &b)
# 	s = "\tit \"#{label}\" do\n"
# 	arglist = args.length.times.map{|i| "arg_#{i}"}.join(', ')
# 	s += "\t\tret = #{name}(#{arglist})\n"
# 	s += yield(label, name, args)
# 	s += "\tend\n\n"
# end
# 
def mk_it_void(label, name, boss, args)
	mk_it_base(label, name, boss, args) do
		"\t\t# ret void\n"
	end
end

def mk_it_bool(label, name, boss, args)
	mk_it_base(label, name, boss, args) do
		"\t\t[true, false].include?(ret).should == true\n"
	end
end

def mk_it(label, name, boss, args, returns)
	mk_it_base(label, name, boss, args) do 
		"\t\tret.should_not == nil\n" +
		"\t\tret.is_a?(#{returns}).should == true\n"
	end
end

def cut_prefix(prefix, c_name)
	# if prefix matches, return amended method name
	prefix.to_s == c_name.to_s[0, prefix.length] ? c_name[prefix.length..-1] : nil
end

# def compose_c(label, prefix, c_name, args, returns)
def compose_c(label, prefix, c_name, args, returns, boss)
# 	puts "prefix: #{prefix}, c_name: #{c_name}"
# 	arglist = mk_arglist("#{boss}_0", args.length)
	ret = chg_type(returns)
	c_name = c_name[1..-1]
	case returns
	when ':void' then mk_it_void(label, "TreeSitterFFI.#{c_name}", boss, args)
	when ':bool' then mk_it_bool(label, "TreeSitterFFI.#{c_name}", boss, args)
	else
		mk_it(label, "TreeSitterFFI.#{c_name}", boss, args, 
			(ret.is_a?(Symbol) ? ret : qual_type(ret)))
	end
end

def compose_rb(label, prefix, c_name, args, returns, boss)
	rb_name = cut_prefix(prefix, c_name)
# 	arglist = mk_arglist("#{boss}_0", args.length)
# 	args.shift
	args = args.map{|e| chg_type(e)}
	returns = chg_type(returns)
	label = "#{rb_name}(#{args[1..-1].join(', ')}) # => #{returns}"
	ret = chg_type(returns)
	
	case returns
	when ':void' then mk_it_void(label, "#{boss}_0.#{rb_name}", nil, args)
	when ':bool' then mk_it_bool(label, "#{boss}_0.#{rb_name}", nil, args)
	else
		mk_it(label, "#{boss}_0.#{rb_name}", nil, args, 
			(ret.is_a?(Symbol) ? ret : qual_type(ret)))
	end
end

# outdir = './gen'
# unless Dir.exists?(outdir)
# 	puts "no #{outdir} dir. exitting."
# 	exit 0
# end
# unless Dir.empty?(outdir)
# 	puts "#{outdir} dir has stuff in it. exitting."
# 	exit 0
# end

require 'fileutils'

$warn_exists = nil
outdir = './gen/sigs'
Dir.mkdir('./gen') unless Dir.exists?('./gen')
if Dir.exists?(outdir)
	if Dir.exists?(outdir + "-keep")
		puts "#{outdir}-keep dir exists. exitting."
		exit 0
	else
		FileUtils.mv(outdir, outdir + "-keep")
	end
elsif Dir.exists?(outdir + "-keep")
	# likely only when you want to rerun relative to prev acceptable, so you rm gen/sigs.
	$warn_exists = "Warning: #{outdir}-keep dir already existed but #{outdir} did not."
end
Dir.mkdir(outdir)
	
["node", "tree", "parser", "query", "language"].each do |bossfile|
	puts "bossfile: #{bossfile}"
	mk_file(outdir, bossfile) do |out_ts, out_rb|
		s = File.read("./lib/tree_sitter_ffi/#{bossfile}.rb")
		calls = s.scan(/wrap_attach\(([^)]+)\)/)
		calls.each do |wrap|
			wrap.each do |w|
				# eg ":ts_node_, [\n\t\t\t[:ts_node_type, [Node.by_value], :string],\n\t..."
				parts = w.scan(/^\s*(:\w+),\s*(.*)/m).flatten
				prefix, entries = parts
				boss = prefix.gsub(/:ts_(\w+)_/, '\1')
				entries = w.scan(/\[\s*:[^\]]*\[[^\]]*\][^\]]*\]/)
				entries = entries.map{|e| e.gsub(/\s+/, ' ')}
				entries.map do |entry|
					# eg ":ts_node_type, [Node.by_value], :string"
					segs = entry.gsub(/\[\s*(:\w+),\s*\[([^\]]*)\],\s*(:?[\w\d.]+)\].*/, 
						'\1@\2@\3').split('@')
					name, args, returns = segs
					puts "  name: #{name}, args: #{args.inspect}"
					args = args.split(', ')
					e = [entry[1..-2], prefix, name, args, returns]

					out_ts << compose_c(*e, boss)
					out_rb << compose_rb(*e, boss)
					e
				end
			end
		end
	end
end

puts
puts $warn_exists if $warn_exists
# name it *.rb, so any syntax highlighting will be ruby
puts "Writing diff -r sigs-keep/ sigs/ to sigs_diff.rb..."
`diff -r -x.* ./gen/sigs-keep ./gen/sigs > ./gen/sigs_diff.rb`

puts "done."
