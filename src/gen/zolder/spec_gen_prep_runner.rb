#### new scaffolder for spec_gen config files!!!

require './src/gen/gen_runner.rb'
require './src/gen/spec_gen_prep/node_sigs_prep.rb'

# Yo, cal: do not keep fussing over this one!!!

# spec_gen.rb is a throw-away, bootstrap script to generate blunt tests for each 
# function sig of the main boss classes (and their mod.ts_ equivalents).
# There is definitely a role for such a script but this is exactly the
# sort of thing better done with a proper language parser not regexps.
# To be continued.

# Re source code style, the script is not comment-aware. Do not put comments within 
# a wrap_attach() entry (eg when it's broken over several lines and you want to 
# note some particular arg) and any whole entries or wrap_attach() blocks 
# commented out will get picked up. Outside of wrap_attach(), everything is ignored.

# 	typedef :pointer, :blang
# 	typedef :strptr, :adoptstring
# 	typedef :uint16, :symbol
# 	typedef :uint16, :field_id
# 	typedef :pointer, :size_p

def chg_type(type)
	case type
	when /:u?int\d+/ then 'Integer'
	when ':bool', ':void' then type
	when ':string' then 'String'
	when /[A-Z][\w.]+/ then type.split('.').first
	# FFI typedefs
	when ':adoptstring', ':strptr' then 'Array' 
	when ':pointer', ':uint32_p', ':size_p', ':array_of_range', 
		':file_pointer', ':query_error_p'
		'Pointer'
	when ':symbol', ':field_id', ':file_descriptor' then 'Integer'
	else
		'WaitWhat'
	end
end

def qual_type(type)
	begin
		::Kernel.const_get(type)
	rescue
		# if type isn't recognized, assume it belongs to tree_sitter_ffi and qualify
		type = "TreeSitterFFI::#{type.to_s}"
	end
end

def mk_descr_head(label, before="")
  expected_result = <<-INDENTED_HEREDOC
# hacky hacky hacky -- generated by src/gen/spec_gen.rb, then COPIED and hand-tweaked

# this spec is only looking to check each ts_ call doesn't raise or crash and 
# returns the right type, given acceptable args

describe "#{label}" do
	before do
    #{before.join("\n\t\t") unless before.empty?}
	end
    
	INDENTED_HEREDOC
end

def mk_it_all(c_name_sym, label, arg_types, ret, prep, &b)
# def mk_it_all(c_name_sym, label, arg_types, ret, prep, &b)
#   puts "mk_it_all c_name_sym: #{c_name_sym.inspect}, label: #{label}"
#   puts "  ret: #{ret}, arg_types: #{arg_types}"

	s = "\tit \"#{label}\" do\n"

#   obj, arglist = prep.fn(c_name_sym.to_sym)
#   puts "  == obj: #{obj.inspect}, arglist: #{arglist.inspect}"
#   
#   # vet argslist.nil? || arglist.is_a?(Array), etc!!!
#   arglist = [] unless arglist
# #   args = arglist.join(', ')
# 
# #   raise "prep args.length != arg_types.length" unless args.length == arg_types.length
#   unless arglist.length == arg_types.length - 1
#     ### label lists args ts_ style, ie with obj included first, but prep asks
#     # only for the other args!!! awkward!!!
#     raise "prep wrong number of args for #{label}"
#   end
  
  # arglist from prep is now a string of comma sepd. split to count, write out as is!!!
  obj, arglist = prep.fn(c_name_sym.to_sym)
  puts "  == obj: #{obj.inspect}, arglist: #{arglist.inspect}"
  
  # if obj is nil, the it needs a patch, so just stub it and move on
  unless obj
    return "\t#{s.strip} end # TBD\n\n"
#     return s += " end # TBD"
  end
  
  
  arglist = "" unless arglist
  
  unless arglist.split(',').length == arg_types.length - 1
    ### label lists args ts_ style, ie with obj included first, but prep asks
    # only for the other args!!! awkward!!!
    raise "prep wrong number of args for #{label}"
  end
  ### consider defaults for unspecified args (all or some?)!!!

  ### arglist is now string of comma sepd, nothing to protect!!!
  # need to protect Strings, Symbols!!!
#   args = arglist.map{|e| e.is_a?(String) || e.is_a?(Symbol) ? e.inspect : e}.join(', ')
	args = arglist
	
# 	name = yield(obj)
# 	s += "\t\tret = #{name}(#{args})\n"
	
	call = yield(obj, args)
		
	s += "\t\tret = #{call}\n"

	s += case ret
  when ':void'
		"\t\t# ret void\n"
	when ':bool'
		"\t\t[true, false].include?(ret).should == true\n"
	else
		t = "\t\tret.should_not == nil\n"
	  qual_ret = (ret.is_a?(Symbol) ? ret : qual_type(ret))
		t += "\t\tret.is_a?(#{qual_ret}).should == true\n"
	end

	s += "\tend\n\n"
end


def cut_prefix(prefix, c_name)
	# if prefix matches, return amended method name
	prefix = prefix[1..-1] # chop : but leave it string!!!
	prefix == c_name[0, prefix.length] ? c_name[prefix.length..-1] : nil
	# already cut :
# 	prefix.to_s == c_name.to_s[0, prefix.length] ? c_name[prefix.length..-1] : nil
end

def compose_c(label, prefix, c_name_sym, arg_types, ret_type, prep)
	ret = chg_type(ret_type)
# 	c_name = c_name_sym[1..-1] # already chopped :
  c_name = c_name_sym

	mk_it_all(c_name_sym, label, arg_types, ret, prep) do |obj, args|
	  name = "TreeSitterFFI.#{c_name}"
    puts "  === obj: #{obj.inspect}, args: #{args.inspect}"
    call = "#{name}(#{obj}" + (args.empty? ?  ")" : ", #{args})")
    puts "  === call: #{call}"
    call
  end
end

def compose_rb(label, prefix, c_name_sym, arg_types, ret_type, prep)
	rb_name = cut_prefix(prefix, c_name_sym)
	arg_types = arg_types.map{|e| chg_type(e)}
	ret = chg_type(ret_type)
	label = "#{rb_name}(#{arg_types[1..-1].join(', ')}) # => #{ret}"
	
	mk_it_all(c_name_sym, label, arg_types, ret, prep) do |obj, args|
	  name = "#{obj}.#{rb_name}"
    call = "#{name}(#{args})"
	end
end

devdir = './src/gen'
gendir = './gen'
outdir = gendir + '/sigs-prep'
srcdir = './lib/tree_sitter_ffi'

runner = GenRunner.new
runner.legacy_prepare_dirs(srcdir, gendir, outdir, devdir, true) #womping

  

def mk_file(outdir, boss, &b)
	out_ts = File.open(outdir+"/ts_#{boss}_spec.rb", "w")
	out_ts << mk_descr_head("ts_#{boss}_spec.rb")
	out_rb = File.open(outdir+"/#{boss}_spec.rb", "w")
	out_rb << mk_descr_head("#{boss}_spec.rb")
	yield(out_ts, out_rb)
	out_ts << "\nend\n"
	out_ts.close
	out_rb << "\nend\n"
	out_rb.close
end

###['node', 'tree', 'parser', 'query', 'language'].each do |bosstag|
['node'].each do |bosstag|
  runner.write_open(:out, :out_ts, "/ts_#{bosstag}_spec.rb", 'w')
#   runner.write_open(:out, :out_rb, "/#{bosstag}_spec.rb", 'w')

  prep = case bosstag
  when 'node' then NodeSigsPrep.new
  end
  
  # head
  runner.write_some(:out_ts, mk_descr_head("ts_#{bosstag}_spec.rb", prep.before))
#   runner.write_some(:out_rb, mk_descr_head("#{bosstag}_spec.rb", prep.before))
  
  # before
  

  s = runner.read(:src, "/#{bosstag}.rb")
  
  calls = s.scan(/wrap_attach\(([^)]+)\)/)
  
  
  
  calls.each do |wrap|
    wrap.each do |w|
      # eg ":ts_node_, [\n\t\t\t[:ts_node_type, [Node.by_value], :string],\n\t..."
      parts = w.scan(/^\s*(:\w+),\s*(.*)/m).flatten
      prefix, entries = parts
      boss = prefix.gsub(/:ts_(\w+)_/, '\1') ###unused???
      entries = w.scan(/\[\s*:[^\]]*\[[^\]]*\][^\]]*\]/)
      entries = entries.map{|e| e.gsub(/\s+/, ' ')}
      entries.map do |entry|
        # eg ":ts_node_type, [Node.by_value], :string"
        segs = entry.gsub(/\[\s*(:\w+),\s*\[([^\]]*)\],\s*(:?[\w\d.]+)\].*/, 
          '\1@\2@\3').split('@')
        name, arg_types, ret_type = segs
        # name looks like ":ts_name", chop : but leave it string!!!
        name = name[1..-1]
        arg_types = arg_types.split(', ')
        e = [entry[1..-2], prefix, name, arg_types, ret_type]

        runner.write_some(:out_ts, compose_c(*e, prep))
#         runner.write_some(:out_rb, compose_rb(*e, prep))
        e
      end
    end
  end

  # tail
  runner.write_some(:out_ts, "\nend\n")
#   runner.write_some(:out_rb, "\nend\n")
  
  runner.write_close(:out_ts)
#   runner.write_close(:out_rb)
end
	
# # name it *.rb, so any syntax highlighting will be ruby
# puts "Writing diff -r sigs-keep/ sigs/ to sigs_diff.rb..."
# `diff -r -x.* ./gen/sigs-keep ./gen/sigs > ./gen/sigs_diff.rb`

puts "done."
