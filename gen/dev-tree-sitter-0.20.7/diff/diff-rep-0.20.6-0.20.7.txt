diff --git a/gen/dev-tree-sitter-0.20.6/pull/tree-sitter-0.20.6/lib/include/tree_sitter/api.h b/gen/dev-tree-sitter-0.20.7/pull/tree-sitter-0.20.7/lib/include/tree_sitter/api.h
index 1ace7be..727dded 100644
--- a/gen/dev-tree-sitter-0.20.6/pull/tree-sitter-0.20.6/lib/include/tree_sitter/api.h
+++ b/gen/dev-tree-sitter-0.20.7/pull/tree-sitter-0.20.7/lib/include/tree_sitter/api.h
@@ -366,6 +366,16 @@ void ts_tree_delete(TSTree *self);
  */
 TSNode ts_tree_root_node(const TSTree *self);
 
+/**
+ * Get the root node of the syntax tree, but with its position
+ * shifted forward by the given offset.
+ */
+TSNode ts_tree_root_node_with_offset(
+  const TSTree *self,
+  uint32_t offset_bytes,
+  TSPoint offset_point
+);
+
 /**
  * Get the language that was used to parse the syntax tree.
  */
@@ -733,6 +743,11 @@ const TSQueryPredicateStep *ts_query_predicates_for_pattern(
   uint32_t *length
 );
 
+bool ts_query_is_pattern_rooted(
+  const TSQuery *self,
+  uint32_t pattern_index
+);
+
 bool ts_query_is_pattern_guaranteed_at_step(
   const TSQuery *self,
   uint32_t byte_offset
diff --git a/gen/dev-tree-sitter-0.20.6/pull/tree-sitter-0.20.6/cli/src/tests/node_test.rs b/gen/dev-tree-sitter-0.20.7/pull/tree-sitter-0.20.7/cli/src/tests/node_test.rs
index 776ca2c..6d5ed61 100644
--- a/gen/dev-tree-sitter-0.20.6/pull/tree-sitter-0.20.6/cli/src/tests/node_test.rs
+++ b/gen/dev-tree-sitter-0.20.7/pull/tree-sitter-0.20.7/cli/src/tests/node_test.rs
@@ -529,6 +529,34 @@ fn test_node_edit() {
     }
 }
 
+#[test]
+fn test_root_node_with_offset() {
+    let mut parser = Parser::new();
+    parser.set_language(get_language("javascript")).unwrap();
+    let tree = parser.parse("  if (a) b", None).unwrap();
+
+    let node = tree.root_node_with_offset(6, Point::new(2, 2));
+    assert_eq!(node.byte_range(), 8..16);
+    assert_eq!(node.start_position(), Point::new(2, 4));
+    assert_eq!(node.end_position(), Point::new(2, 12));
+
+    let child = node.child(0).unwrap().child(2).unwrap();
+    assert_eq!(child.kind(), "expression_statement");
+    assert_eq!(child.byte_range(), 15..16);
+    assert_eq!(child.start_position(), Point::new(2, 11));
+    assert_eq!(child.end_position(), Point::new(2, 12));
+
+    let mut cursor = node.walk();
+    cursor.goto_first_child();
+    cursor.goto_first_child();
+    cursor.goto_next_sibling();
+    let child = cursor.node();
+    assert_eq!(child.kind(), "parenthesized_expression");
+    assert_eq!(child.byte_range(), 11..14);
+    assert_eq!(child.start_position(), Point::new(2, 7));
+    assert_eq!(child.end_position(), Point::new(2, 10));
+}
+
 #[test]
 fn test_node_is_extra() {
     let mut parser = Parser::new();
diff --git a/gen/dev-tree-sitter-0.20.6/pull/tree-sitter-0.20.6/cli/src/tests/tree_test.rs b/gen/dev-tree-sitter-0.20.7/pull/tree-sitter-0.20.7/cli/src/tests/tree_test.rs
index d2b1eb8..d5c5454 100644
--- a/gen/dev-tree-sitter-0.20.6/pull/tree-sitter-0.20.6/cli/src/tests/tree_test.rs
+++ b/gen/dev-tree-sitter-0.20.7/pull/tree-sitter-0.20.7/cli/src/tests/tree_test.rs
@@ -89,14 +89,11 @@ fn test_tree_edit() {
         let child2 = expr.child(1).unwrap();
 
         assert!(expr.has_changes());
-        assert_eq!(expr.start_byte(), 4);
-        assert_eq!(expr.end_byte(), 17);
+        assert_eq!(expr.byte_range(), 4..17);
         assert!(child1.has_changes());
-        assert_eq!(child1.start_byte(), 4);
-        assert_eq!(child1.end_byte(), 7);
+        assert_eq!(child1.byte_range(), 4..7);
         assert!(!child2.has_changes());
-        assert_eq!(child2.start_byte(), 9);
-        assert_eq!(child2.end_byte(), 12);
+        assert_eq!(child2.byte_range(), 9..12);
     }
 
     // replacement starting at the edge of the tree's padding:
@@ -117,14 +114,11 @@ fn test_tree_edit() {
         let child2 = expr.child(1).unwrap();
 
         assert!(expr.has_changes());
-        assert_eq!(expr.start_byte(), 4);
-        assert_eq!(expr.end_byte(), 17);
+        assert_eq!(expr.byte_range(), 4..17);
         assert!(child1.has_changes());
-        assert_eq!(child1.start_byte(), 4);
-        assert_eq!(child1.end_byte(), 7);
+        assert_eq!(child1.byte_range(), 4..7);
         assert!(!child2.has_changes());
-        assert_eq!(child2.start_byte(), 9);
-        assert_eq!(child2.end_byte(), 12);
+        assert_eq!(child2.byte_range(), 9..12);
     }
 
     // deletion that spans more than one child node:
@@ -146,17 +140,13 @@ fn test_tree_edit() {
         let child3 = expr.child(2).unwrap();
 
         assert!(expr.has_changes());
-        assert_eq!(expr.start_byte(), 4);
-        assert_eq!(expr.end_byte(), 8);
+        assert_eq!(expr.byte_range(), 4..8);
         assert!(child1.has_changes());
-        assert_eq!(child1.start_byte(), 4);
-        assert_eq!(child1.end_byte(), 4);
+        assert_eq!(child1.byte_range(), 4..4);
         assert!(child2.has_changes());
-        assert_eq!(child2.start_byte(), 4);
-        assert_eq!(child2.end_byte(), 4);
+        assert_eq!(child2.byte_range(), 4..4);
         assert!(child3.has_changes());
-        assert_eq!(child3.start_byte(), 5);
-        assert_eq!(child3.end_byte(), 8);
+        assert_eq!(child3.byte_range(), 5..8);
     }
 
     // insertion at the end of the tree:
@@ -178,14 +168,67 @@ fn test_tree_edit() {
         let child3 = expr.child(2).unwrap();
 
         assert!(expr.has_changes());
-        assert_eq!(expr.start_byte(), 2);
-        assert_eq!(expr.end_byte(), 16);
+        assert_eq!(expr.byte_range(), 2..16);
         assert!(!child1.has_changes());
-        assert_eq!(child1.end_byte(), 5);
+        assert_eq!(child1.byte_range(), 2..5);
         assert!(!child2.has_changes());
-        assert_eq!(child2.end_byte(), 10);
+        assert_eq!(child2.byte_range(), 7..10);
+        assert!(child3.has_changes());
+        assert_eq!(child3.byte_range(), 12..16);
+    }
+
+    // replacement that starts within a token and extends beyond the end of the tree:
+    // resize the token and empty out any subsequent child nodes.
+    {
+        let mut tree = tree.clone();
+        tree.edit(&InputEdit {
+            start_byte: 3,
+            old_end_byte: 90,
+            new_end_byte: 4,
+            start_position: Point::new(0, 3),
+            old_end_position: Point::new(0, 90),
+            new_end_position: Point::new(0, 4),
+        });
+
+        let expr = tree.root_node().child(0).unwrap().child(0).unwrap();
+        let child1 = expr.child(0).unwrap();
+        let child2 = expr.child(1).unwrap();
+        let child3 = expr.child(2).unwrap();
+        assert_eq!(expr.byte_range(), 2..4);
+        assert!(expr.has_changes());
+        assert_eq!(child1.byte_range(), 2..4);
+        assert!(child1.has_changes());
+        assert_eq!(child2.byte_range(), 4..4);
+        assert!(child2.has_changes());
+        assert_eq!(child3.byte_range(), 4..4);
+        assert!(child3.has_changes());
+    }
+
+    // replacement that starts in whitespace and extends beyond the end of the tree:
+    // shift the token's start position and empty out its content.
+    {
+        let mut tree = tree.clone();
+        tree.edit(&InputEdit {
+            start_byte: 6,
+            old_end_byte: 90,
+            new_end_byte: 8,
+            start_position: Point::new(0, 6),
+            old_end_position: Point::new(0, 90),
+            new_end_position: Point::new(0, 8),
+        });
+
+        let expr = tree.root_node().child(0).unwrap().child(0).unwrap();
+        let child1 = expr.child(0).unwrap();
+        let child2 = expr.child(1).unwrap();
+        let child3 = expr.child(2).unwrap();
+        assert_eq!(expr.byte_range(), 2..8);
+        assert!(expr.has_changes());
+        assert_eq!(child1.byte_range(), 2..5);
+        assert!(!child1.has_changes());
+        assert_eq!(child2.byte_range(), 8..8);
+        assert!(child2.has_changes());
+        assert_eq!(child3.byte_range(), 8..8);
         assert!(child3.has_changes());
-        assert_eq!(child3.end_byte(), 16);
     }
 }
 
diff --git a/gen/dev-tree-sitter-0.20.6/pull/tree-sitter-0.20.6/cli/src/tests/query_test.rs b/gen/dev-tree-sitter-0.20.7/pull/tree-sitter-0.20.7/cli/src/tests/query_test.rs
index a9961b8..31cb803 100644
--- a/gen/dev-tree-sitter-0.20.6/pull/tree-sitter-0.20.6/cli/src/tests/query_test.rs
+++ b/gen/dev-tree-sitter-0.20.7/pull/tree-sitter-0.20.7/cli/src/tests/query_test.rs
@@ -1687,6 +1687,66 @@ fn test_query_matches_with_too_many_permutations_to_track() {
     });
 }
 
+#[test]
+fn test_query_sibling_patterns_dont_match_children_of_an_error() {
+    allocations::record(|| {
+        let language = get_language("rust");
+        let query = Query::new(
+            language,
+            r#"
+            ("{" @open "}" @close)
+
+            [
+              (line_comment)
+              (block_comment)
+            ] @comment
+
+            ("<" @first "<" @second)
+            "#,
+        )
+        .unwrap();
+
+        // Most of the document will fail to parse, resulting in a
+        // large number of tokens that are *direct* children of an
+        // ERROR node.
+        //
+        // These children should still match, unless they are part
+        // of a "non-rooted" pattern, in which there are multiple
+        // top-level sibling nodes. Those patterns should not match
+        // directly inside of an error node, because the contents of
+        // an error node are not syntactically well-structured, so we
+        // would get many spurious matches.
+        let source = "
+            fn a() {}
+
+            <<<<<<<<<< add pub b fn () {}
+            // comment 1
+            pub fn b() {
+            /* comment 2 */
+            ==========
+            pub fn c() {
+            // comment 3
+            >>>>>>>>>> add pub c fn () {}
+            }
+        ";
+
+        let mut parser = Parser::new();
+        parser.set_language(language).unwrap();
+        let tree = parser.parse(&source, None).unwrap();
+        let mut cursor = QueryCursor::new();
+        let matches = cursor.matches(&query, tree.root_node(), source.as_bytes());
+        assert_eq!(
+            collect_matches(matches, &query, source),
+            &[
+                (0, vec![("open", "{"), ("close", "}")]),
+                (1, vec![("comment", "// comment 1")]),
+                (1, vec![("comment", "/* comment 2 */")]),
+                (1, vec![("comment", "// comment 3")]),
+            ],
+        );
+    });
+}
+
 #[test]
 fn test_query_matches_with_alternatives_and_too_many_permutations_to_track() {
     allocations::record(|| {
@@ -2002,6 +2062,68 @@ fn test_query_matches_with_unrooted_patterns_intersecting_byte_range() {
     });
 }
 
+#[test]
+fn test_query_matches_with_wildcard_at_root_intersecting_byte_range() {
+    allocations::record(|| {
+        let language = get_language("python");
+        let query = Query::new(
+            language,
+            "
+            [
+                (_ body: (block))
+                (_ consequence: (block))
+            ] @indent
+            ",
+        )
+        .unwrap();
+
+        let source = "
+            class A:
+                def b():
+                    if c:
+                        d
+                    else:
+                        e
+        "
+        .trim();
+
+        let mut parser = Parser::new();
+        parser.set_language(language).unwrap();
+        let tree = parser.parse(source, None).unwrap();
+        let mut cursor = QueryCursor::new();
+
+        // After the first line of the class definition
+        let offset = source.find("A:").unwrap() + 2;
+        let matches = cursor
+            .set_byte_range(offset..offset)
+            .matches(&query, tree.root_node(), source.as_bytes())
+            .map(|mat| mat.captures[0].node.kind())
+            .collect::<Vec<_>>();
+        assert_eq!(matches, &["class_definition"]);
+
+        // After the first line of the function definition
+        let offset = source.find("b():").unwrap() + 4;
+        let matches = cursor
+            .set_byte_range(offset..offset)
+            .matches(&query, tree.root_node(), source.as_bytes())
+            .map(|mat| mat.captures[0].node.kind())
+            .collect::<Vec<_>>();
+        assert_eq!(matches, &["class_definition", "function_definition"]);
+
+        // After the first line of the if statement
+        let offset = source.find("c:").unwrap() + 2;
+        let matches = cursor
+            .set_byte_range(offset..offset)
+            .matches(&query, tree.root_node(), source.as_bytes())
+            .map(|mat| mat.captures[0].node.kind())
+            .collect::<Vec<_>>();
+        assert_eq!(
+            matches,
+            &["class_definition", "function_definition", "if_statement"]
+        );
+    });
+}
+
 #[test]
 fn test_query_captures_within_byte_range_assigned_after_iterating() {
     allocations::record(|| {
@@ -2825,7 +2947,7 @@ fn test_query_captures_with_many_nested_results_with_fields() {
         .unwrap();
 
         // The outer expression does not match the pattern, but the consequence of the ternary
-        // is an object that *does* contain many occurences of the pattern.
+        // is an object that *does* contain many occurrences of the pattern.
         let count = 50;
         let mut source = "a ? {".to_owned();
         for i in 0..count {
@@ -3857,6 +3979,97 @@ fn test_query_is_pattern_guaranteed_at_step() {
     });
 }
 
+#[test]
+fn test_query_is_pattern_rooted() {
+    struct Row {
+        description: &'static str,
+        pattern: &'static str,
+        is_rooted: bool,
+    }
+
+    let rows = [
+        Row {
+            description: "simple token",
+            pattern: r#"(identifier)"#,
+            is_rooted: true,
+        },
+        Row {
+            description: "simple non-terminal",
+            pattern: r#"(function_definition name: (identifier))"#,
+            is_rooted: true,
+        },
+        Row {
+            description: "alternative of many tokens",
+            pattern: r#"["if" "def" (identifier) (comment)]"#,
+            is_rooted: true,
+        },
+        Row {
+            description: "alternative of many non-terminals",
+            pattern: r#"[
+                (function_definition name: (identifier))
+                (class_definition name: (identifier))
+                (block)
+            ]"#,
+            is_rooted: true,
+        },
+        Row {
+            description: "two siblings",
+            pattern: r#"("{" "}")"#,
+            is_rooted: false,
+        },
+        Row {
+            description: "top-level repetition",
+            pattern: r#"(comment)*"#,
+            is_rooted: false,
+        },
+        Row {
+            description: "alternative where one option has two siblings",
+            pattern: r#"[
+                (block)
+                (class_definition)
+                ("(" ")")
+                (function_definition)
+            ]"#,
+            is_rooted: false,
+        },
+        Row {
+            description: "alternative where one option has a top-level repetition",
+            pattern: r#"[
+                (block)
+                (class_definition)
+                (comment)*
+                (function_definition)
+            ]"#,
+            is_rooted: false,
+        },
+    ];
+
+    allocations::record(|| {
+        eprintln!("");
+
+        let language = get_language("python");
+        for row in &rows {
+            if let Some(filter) = EXAMPLE_FILTER.as_ref() {
+                if !row.description.contains(filter.as_str()) {
+                    continue;
+                }
+            }
+            eprintln!("  query example: {:?}", row.description);
+            let query = Query::new(language, row.pattern).unwrap();
+            assert_eq!(
+                query.is_pattern_rooted(0),
+                row.is_rooted,
+                "Description: {}, Pattern: {:?}",
+                row.description,
+                row.pattern
+                    .split_ascii_whitespace()
+                    .collect::<Vec<_>>()
+                    .join(" "),
+            )
+        }
+    });
+}
+
 #[test]
 fn test_capture_quantifiers() {
     struct Row {
