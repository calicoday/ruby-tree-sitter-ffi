# hacky hacky hacky -- generated by src/gen/spec_gen.rb, then COPIED and hand-tweaked

# this spec is only looking to check each ts_ call doesn't raise or crash and 
# returns the right type, given acceptable args

describe "node_sigs_spec.rb" do
  before do
    
  end
    
  it ":ts_node_type, [Node.by_value], :string" do
    ret = TreeSitterFFI.ts_node_type(TreeSitterFFI::Node.new)
    ret.should_not == nil
    ret.is_a?(String).should == true
  end

  it ":ts_node_symbol, [Node.by_value], :uint16" do
    ret = TreeSitterFFI.ts_node_symbol(TreeSitterFFI::Node.new)
    ret.should_not == nil
    ret.is_a?(Integer).should == true
  end

  it ":ts_node_start_byte, [Node.by_value], :uint32" do
    ret = TreeSitterFFI.ts_node_start_byte(TreeSitterFFI::Node.new)
    ret.should_not == nil
    ret.is_a?(Integer).should == true
  end

  it ":ts_node_start_point, [Node.by_value], Point.by_value" do
    ret = TreeSitterFFI.ts_node_start_point(TreeSitterFFI::Node.new)
    ret.should_not == nil
    ret.is_a?(TreeSitterFFI::Point).should == true
  end

  it ":ts_node_end_byte, [Node.by_value], :uint32" do
    ret = TreeSitterFFI.ts_node_end_byte(TreeSitterFFI::Node.new)
    ret.should_not == nil
    ret.is_a?(Integer).should == true
  end

  it ":ts_node_end_point, [Node.by_value], Point.by_value" do
    ret = TreeSitterFFI.ts_node_end_point(TreeSitterFFI::Node.new)
    ret.should_not == nil
    ret.is_a?(TreeSitterFFI::Point).should == true
  end

  it ":ts_node_string, [Node.by_value], :adoptstring" do
    ret = TreeSitterFFI.ts_node_string(TreeSitterFFI::Node.new)
    ret.should_not == nil
    ret.is_a?(Array).should == true
  end

  it ":ts_node_is_null, [Node.by_value], :bool" do
    ret = TreeSitterFFI.ts_node_is_null(TreeSitterFFI::Node.new)
    [true, false].include?(ret).should == true
  end

  it ":ts_node_is_named, [Node.by_value], :bool" do
    ret = TreeSitterFFI.ts_node_is_named(TreeSitterFFI::Node.new)
    [true, false].include?(ret).should == true
  end

  it ":ts_node_is_missing, [Node.by_value], :bool" do
    ret = TreeSitterFFI.ts_node_is_missing(TreeSitterFFI::Node.new)
    [true, false].include?(ret).should == true
  end

  it ":ts_node_is_extra, [Node.by_value], :bool" do
    ret = TreeSitterFFI.ts_node_is_extra(TreeSitterFFI::Node.new)
    [true, false].include?(ret).should == true
  end

  it ":ts_node_has_changes, [Node.by_value], :bool" do
    ret = TreeSitterFFI.ts_node_has_changes(TreeSitterFFI::Node.new)
    [true, false].include?(ret).should == true
  end

  it ":ts_node_has_error, [Node.by_value], :bool" do
    ret = TreeSitterFFI.ts_node_has_error(TreeSitterFFI::Node.new)
    [true, false].include?(ret).should == true
  end

  it ":ts_node_parent, [Node.by_value], Node.by_value" do
    ret = TreeSitterFFI.ts_node_parent(TreeSitterFFI::Node.new)
    ret.should_not == nil
    ret.is_a?(TreeSitterFFI::Node).should == true
  end

  it ":ts_node_child, [Node.by_value, :uint32], Node.by_value" do
    ret = TreeSitterFFI.ts_node_child(TreeSitterFFI::Node.new, ::FFI::MemoryPointer.new(:uint32, 1))
    ret.should_not == nil
    ret.is_a?(TreeSitterFFI::Node).should == true
  end

  it ":ts_node_field_name_for_child, [Node.by_value, :uint32], :string" do
    ret = TreeSitterFFI.ts_node_field_name_for_child(TreeSitterFFI::Node.new, ::FFI::MemoryPointer.new(:uint32, 1))
    ret.should_not == nil
    ret.is_a?(String).should == true
  end

  it ":ts_node_child_count, [Node.by_value], :uint32" do
    ret = TreeSitterFFI.ts_node_child_count(TreeSitterFFI::Node.new)
    ret.should_not == nil
    ret.is_a?(Integer).should == true
  end

  it ":ts_node_named_child, [Node.by_value, :uint32], Node.by_value" do
    ret = TreeSitterFFI.ts_node_named_child(TreeSitterFFI::Node.new, ::FFI::MemoryPointer.new(:uint32, 1))
    ret.should_not == nil
    ret.is_a?(TreeSitterFFI::Node).should == true
  end

  it ":ts_node_named_child_count, [Node.by_value], :uint32" do
    ret = TreeSitterFFI.ts_node_named_child_count(TreeSitterFFI::Node.new)
    ret.should_not == nil
    ret.is_a?(Integer).should == true
  end

  it ":ts_node_child_by_field_name, [Node.by_value, :string, :uint32], Node.by_value" do
    ret = TreeSitterFFI.ts_node_child_by_field_name(TreeSitterFFI::Node.new, ::FFI::MemoryPointer.new(:string, 1), ::FFI::MemoryPointer.new(:uint32, 1))
    ret.should_not == nil
    ret.is_a?(TreeSitterFFI::Node).should == true
  end

  it ":ts_node_child_by_field_id, [Node.by_value, :field_id], Node.by_value" do
    ret = TreeSitterFFI.ts_node_child_by_field_id(TreeSitterFFI::Node.new, ::FFI::MemoryPointer.new(:field_id, 1))
    ret.should_not == nil
    ret.is_a?(TreeSitterFFI::Node).should == true
  end

  it ":ts_node_next_sibling, [Node.by_value], Node.by_value" do
    ret = TreeSitterFFI.ts_node_next_sibling(TreeSitterFFI::Node.new)
    ret.should_not == nil
    ret.is_a?(TreeSitterFFI::Node).should == true
  end

  it ":ts_node_prev_sibling, [Node.by_value], Node.by_value" do
    ret = TreeSitterFFI.ts_node_prev_sibling(TreeSitterFFI::Node.new)
    ret.should_not == nil
    ret.is_a?(TreeSitterFFI::Node).should == true
  end

  it ":ts_node_next_named_sibling, [Node.by_value], Node.by_value" do
    ret = TreeSitterFFI.ts_node_next_named_sibling(TreeSitterFFI::Node.new)
    ret.should_not == nil
    ret.is_a?(TreeSitterFFI::Node).should == true
  end

  it ":ts_node_prev_named_sibling, [Node.by_value], Node.by_value" do
    ret = TreeSitterFFI.ts_node_prev_named_sibling(TreeSitterFFI::Node.new)
    ret.should_not == nil
    ret.is_a?(TreeSitterFFI::Node).should == true
  end

  it ":ts_node_first_child_for_byte, [Node.by_value, :uint32], Node.by_value" do
    ret = TreeSitterFFI.ts_node_first_child_for_byte(TreeSitterFFI::Node.new, ::FFI::MemoryPointer.new(:uint32, 1))
    ret.should_not == nil
    ret.is_a?(TreeSitterFFI::Node).should == true
  end

  it ":ts_node_first_named_child_for_byte, [Node.by_value, :uint32], Node.by_value" do
    ret = TreeSitterFFI.ts_node_first_named_child_for_byte(TreeSitterFFI::Node.new, ::FFI::MemoryPointer.new(:uint32, 1))
    ret.should_not == nil
    ret.is_a?(TreeSitterFFI::Node).should == true
  end

  it ":ts_node_descendant_for_byte_range, [Node.by_value, :uint32, :uint32], Node.by_value" do
    ret = TreeSitterFFI.ts_node_descendant_for_byte_range(TreeSitterFFI::Node.new, ::FFI::MemoryPointer.new(:uint32, 1), ::FFI::MemoryPointer.new(:uint32, 1))
    ret.should_not == nil
    ret.is_a?(TreeSitterFFI::Node).should == true
  end

  it ":ts_node_descendant_for_point_range, [Node.by_value, Point.by_value, Point.by_value], Node.by_value" do
    ret = TreeSitterFFI.ts_node_descendant_for_point_range(TreeSitterFFI::Node.new, TreeSitterFFI::Point.new, TreeSitterFFI::Point.new)
    ret.should_not == nil
    ret.is_a?(TreeSitterFFI::Node).should == true
  end

  it ":ts_node_named_descendant_for_byte_range, [Node.by_value, :uint32, :uint32], Node.by_value" do
    ret = TreeSitterFFI.ts_node_named_descendant_for_byte_range(TreeSitterFFI::Node.new, ::FFI::MemoryPointer.new(:uint32, 1), ::FFI::MemoryPointer.new(:uint32, 1))
    ret.should_not == nil
    ret.is_a?(TreeSitterFFI::Node).should == true
  end

  it ":ts_node_named_descendant_for_point_range, [Node.by_value, Point.by_value, Point.by_value], Node.by_value" do
    ret = TreeSitterFFI.ts_node_named_descendant_for_point_range(TreeSitterFFI::Node.new, TreeSitterFFI::Point.new, TreeSitterFFI::Point.new)
    ret.should_not == nil
    ret.is_a?(TreeSitterFFI::Node).should == true
  end

  it ":ts_node_edit, [Node.by_ref, InputEdit.by_ref], :void" do
    ret = TreeSitterFFI.ts_node_edit(TreeSitterFFI::Node.new, TreeSitterFFI::InputEdit.new)
    # ret void
  end

  it ":ts_node_eq, [Node.by_value, Node.by_value], :bool" do
    ret = TreeSitterFFI.ts_node_eq(TreeSitterFFI::Node.new, TreeSitterFFI::Node.new)
    [true, false].include?(ret).should == true
  end

end
