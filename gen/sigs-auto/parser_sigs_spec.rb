# hacky hacky hacky -- generated by src/gen/spec_gen.rb, then COPIED and hand-tweaked

# this spec is only looking to check each ts_ call doesn't raise or crash and 
# returns the right type, given acceptable args

describe "parser_sigs_spec.rb" do
  before do
    
  end
    
  it ":ts_parser_set_language, [Parser, Language], :bool" do
    ret = TreeSitterFFI.ts_parser_set_language(TreeSitterFFI::Parser.new, TreeSitterFFI::Language.new)
    [true, false].include?(ret).should == true
  end

  it ":ts_parser_language, [Parser], Language" do
    ret = TreeSitterFFI.ts_parser_language(TreeSitterFFI::Parser.new)
    ret.should_not == nil
    ret.is_a?(TreeSitterFFI::Language).should == true
  end

  it ":ts_parser_set_included_ranges, [Parser, Range.by_ref, :uint32], :bool" do
    ret = TreeSitterFFI.ts_parser_set_included_ranges(TreeSitterFFI::Parser.new, Range.new, ::FFI::MemoryPointer.new(:uint32, 1))
    [true, false].include?(ret).should == true
  end

  it ":ts_parser_included_ranges, [Parser, :uint32_p], :array_of_range" do
    ret = TreeSitterFFI.ts_parser_included_ranges(TreeSitterFFI::Parser.new, ::FFI::MemoryPointer.new(:uint32, 1))
    ret.should_not == nil
    ret.is_a?(FFI::Pointer).should == true
  end

  it ":ts_parser_parse, [Parser, Tree, Input.by_value], Tree" do
    ret = TreeSitterFFI.ts_parser_parse(TreeSitterFFI::Parser.new, TreeSitterFFI::Tree.new, TreeSitterFFI::Input.new)
    ret.should_not == nil
    ret.is_a?(TreeSitterFFI::Tree).should == true
  end

  it ":ts_parser_parse_string, [Parser, Tree, :string, :uint32], Tree" do
    ret = TreeSitterFFI.ts_parser_parse_string(TreeSitterFFI::Parser.new, TreeSitterFFI::Tree.new, ::FFI::MemoryPointer.new(:string, 1), ::FFI::MemoryPointer.new(:uint32, 1))
    ret.should_not == nil
    ret.is_a?(TreeSitterFFI::Tree).should == true
  end

  it ":ts_parser_parse_string_encoding, [Parser, Tree, :string, :uint32, EnumInputEncoding], Tree" do
    ret = TreeSitterFFI.ts_parser_parse_string_encoding(TreeSitterFFI::Parser.new, TreeSitterFFI::Tree.new, ::FFI::MemoryPointer.new(:string, 1), ::FFI::MemoryPointer.new(:uint32, 1), TreeSitterFFI::EnumInputEncoding.new)
    ret.should_not == nil
    ret.is_a?(TreeSitterFFI::Tree).should == true
  end

  it ":ts_parser_reset, [Parser], :void" do
    ret = TreeSitterFFI.ts_parser_reset(TreeSitterFFI::Parser.new)
    # ret void
  end

  it ":ts_parser_set_timeout_micros, [Parser, :uint64], :void" do
    ret = TreeSitterFFI.ts_parser_set_timeout_micros(TreeSitterFFI::Parser.new, ::FFI::MemoryPointer.new(:uint64, 1))
    # ret void
  end

  it ":ts_parser_timeout_micros, [Parser], :uint64" do
    ret = TreeSitterFFI.ts_parser_timeout_micros(TreeSitterFFI::Parser.new)
    ret.should_not == nil
    ret.is_a?(Integer).should == true
  end

  it ":ts_parser_set_cancellation_flag, [Parser, :size_p], :void" do
    ret = TreeSitterFFI.ts_parser_set_cancellation_flag(TreeSitterFFI::Parser.new, ::FFI::MemoryPointer.new(:size, 1))
    # ret void
  end

  it ":ts_parser_cancellation_flag, [Parser], :size_p" do
    ret = TreeSitterFFI.ts_parser_cancellation_flag(TreeSitterFFI::Parser.new)
    ret.should_not == nil
    ret.is_a?(FFI::Pointer).should == true
  end

  it ":ts_parser_set_logger, [Parser, Logger.by_value], :void" do
    ret = TreeSitterFFI.ts_parser_set_logger(TreeSitterFFI::Parser.new, TreeSitterFFI::Logger.new)
    # ret void
  end

  it ":ts_parser_logger, [Parser], Logger.by_value" do
    ret = TreeSitterFFI.ts_parser_logger(TreeSitterFFI::Parser.new)
    ret.should_not == nil
    ret.is_a?(TreeSitterFFI::Logger).should == true
  end

  it ":ts_parser_print_dot_graphs, [Parser, :file_descriptor], :void" do
    ret = TreeSitterFFI.ts_parser_print_dot_graphs(TreeSitterFFI::Parser.new, ::FFI::MemoryPointer.new(:file_descriptor, 1))
    # ret void
  end

end
