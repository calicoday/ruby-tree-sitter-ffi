# hacky hacky hacky -- generated by src/gen/spec_gen.rb, then COPIED and hand-tweaked

# this spec is only looking to check each ts_ call doesn't raise or crash and 
# returns the right type, given acceptable args

describe "parser_patch_spec_blank.rb" do
  before do
    @pars = TreeSitterFFI.parser
    @json = TreeSitterFFI.parser_json
    @pars.set_language(@json).should == true
    @input = "[1, null]"
    @tree = @pars.parse_string(nil, @input, @input.length)
  end

		# type_arr is array of type or [type, value]
		# eg [:uint32, [:string, "aha!!"]]
# 		def bufs(type_arr, &b)
# 		  p_arr = type_arr.map{|e| e.is_a?(Array) ? e : [e]}.map do |type, v| 
# 		    o = FFI::MemoryPointer.new(e, 1)
# 		    o.write(type, v) if v
# 		    [o, type]
# 		  end
# 		  ret = yield *p_arr
# 		  [ret, p_arr.map{|e, type| e.get(type, 0)}]
# # 		  p_arr.map{|e, type| e.read(type)}
# 		end
# 		def incl_ranges() # => Array
# 		  ret, *got = bufs([:pointer]){|len_p| ts_parser_included_ranges(self, len_p)}
# 		  
# 		  ret, *got = bufs([:pointer]) do |len_p|
#         ts_parser_included_ranges(self, len_p)
#       end
#       len = got[0]
#       TreeSitterFFI::Range.new(ret).burst(len)
#     end
    
  # ret is array of Range, arg_1 is pointer to array len.
  it ":ts_parser_included_ranges, [Parser, :uint32_p], :array_of_range" do
#     :ts_parser_included_ranges.should == :FIXME
#     ret = TreeSitterFFI.ts_parser_included_ranges()
#     ret.should_not == nil
#     ret.is_a?(FFI::Pointer).should == true

    ret, *got = SpecUtil::bufs([:uint32_p]) do |len_p| 
      TreeSitterFFI.ts_parser_included_ranges(@pars, len_p)
    end
    ret.should_not == nil
    ret.is_a?(FFI::Pointer).should == true
    len = got[0]    
    len.should_not == nil
    len.is_a?(Integer).should == true
    
#     arg_1 = FFI::MemoryPointer.new(:uint32, 1)
#     ret = TreeSitterFFI.ts_parser_included_ranges(@pars, arg_1)
#     ret.should_not == nil
#     ret.is_a?(FFI::Pointer).should == true
#     len = arg_1.get(:uint32, 0)
#     len.should_not == nil
#     len.is_a?(Integer).should == true
  end

  it ":ts_parser_parse, [Parser, Tree, Input.by_value], Tree" do
    :ts_parser_parse.should == :FIXME
    ret = TreeSitterFFI.ts_parser_parse()
    ret.should_not == nil
    ret.is_a?(TreeSitterFFI::Tree).should == true
  end

  it ":ts_parser_set_cancellation_flag, [Parser, :size_p], :void" do
#     :ts_parser_set_cancellation_flag.should == :FIXME
#     # :size_p is Pointer
#     ret = TreeSitterFFI.ts_parser_set_cancellation_flag()
#     # ret void

#     ret, *got = SpecUtil::bufs([:size_p]) do |flag_p| 
    ret, *got = SpecUtil::bufs([:size_t_p]) do |flag_p| 
      TreeSitterFFI.ts_parser_set_cancellation_flag(@pars, flag_p)
    end

#     arg_1 = FFI::MemoryPointer.new(:pointer, 1) # :size_p is Pointer
#     ret = TreeSitterFFI.ts_parser_set_cancellation_flag(@pars, arg_1)
    # ret void
  end

  it ":ts_parser_set_logger, [Parser, Logger.by_value], :void" do
    :ts_parser_set_logger.should == :FIXME # :not_impl
    ret = TreeSitterFFI.ts_parser_set_logger()
    # ret void
  end

  # getting nil ret in the form of #<FFI::Pointer address=0x0000000000000000> ???!!!
  it ":ts_parser_logger, [Parser], Logger.by_value" do
    :ts_parser_logger.should == :FIXME # :not_impl
    ret = TreeSitterFFI.ts_parser_logger()
    ret.should_not == nil
    ret.is_a?(TreeSitterFFI::Logger).should == true
  end

end
