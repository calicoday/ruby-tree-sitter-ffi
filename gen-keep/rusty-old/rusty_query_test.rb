# this is a simplistic translation-by-regexp to ruby, generated by 
# src/gen/rusty_gen.rb, of the tree-sitter test:
# tree-sitter/cli/src/tests/query_test.rs


def test_query_errors_on_invalid_syntax()
    # TreeSitterFFI::allocations.record(|| {
        language = get_language("javascript")

        assert!(TreeSitterFFI::Query.make(language, "(if_statement)").is_ok())
        assert!(TreeSitterFFI::Query.make(
            language,
            "(if_statement condition:(parenthesized_expression (identifier)))"
        )
        .is_ok())

        # Mismatched parens
        assert_eq!(
            TreeSitterFFI::Query.make(language, "(if_statement").message,
            [
                "(if_statement", #
                "             ^",
            ]
            .join("\n")
        )
        assert_eq!(
            TreeSitterFFI::Query.make(language, "; comment 1\n; comment 2\n  (if_statement))")
                                .message,
            [
                "  (if_statement))", #
                "                ^",
            ]
            .join("\n")
        )

        # Return an error at the *beginning* of a bare identifier not followed a colon.
        # If there's a colon but no pattern, return an error at the end of the colon.
        assert_eq!(
            TreeSitterFFI::Query.make(language, "(if_statement identifier)")
                                .message,
            [
                "(if_statement identifier)", #
                "              ^",
            ]
            .join("\n")
        )
        assert_eq!(
            TreeSitterFFI::Query.make(language, "(if_statement condition:)")
                                .message,
            [
                "(if_statement condition:)", #
                "                        ^",
            ]
            .join("\n")
        )

        # Return an error at the beginning of an unterminated string.
        assert_eq!(
            TreeSitterFFI::Query.make(language, %q%(identifier) "h % )
                                .message,
            [
                %q%(identifier) "h % , #
                %q%             ^% ,
            ]
            .join("\n")
        )

        assert_eq!(
            TreeSitterFFI::Query.make(language, %q%((identifier) ()% )
                                .message,
            [
                "((identifier) ()", #
                "               ^",
            ]
            .join("\n")
        )
        assert_eq!(
            TreeSitterFFI::Query.make(language, %q%((identifier) [])% )
                                .message,
            [
                "((identifier) [])", #
                "               ^",
            ]
            .join("\n")
        )
        assert_eq!(
            TreeSitterFFI::Query.make(language, %q%((identifier) (#a)% )
                                .message,
            [
                "((identifier) (#a)", #
                "                  ^",
            ]
            .join("\n")
        )
        assert_eq!(
            TreeSitterFFI::Query.make(language, %q%((identifier) @x (#eq? @x a% )
                                .message,
            [
                %q%((identifier) @x (#eq? @x a% ,
                %q%                           ^% ,
            ]
            .join("\n")
        )

        # Need at least one child node for a child anchor
        assert_eq!(
            TreeSitterFFI::Query.make(language, %q%(statement_block .)% )
                                .message,
            [
                #
                %q%(statement_block .)% ,
                %q%                  ^% 
            ]
            .join("\n")
        )

        # Need a field name after a negated field operator
        assert_eq!(
            TreeSitterFFI::Query.make(language, %q%(statement_block ! (if_statement))% )
                                .message,
            [
                %q%(statement_block ! (if_statement))% ,
                %q%                   ^% 
            ]
            .join("\n")
        )

        # tree-sitter/tree-sitter/issues/968
        assert_eq!(
            TreeSitterFFI::Query.make(get_language("c"), %q%(parameter_list [ ")" @foo)% )
                                .message,
            [
                %q%(parameter_list [ ")" @foo)% ,
                %q%                          ^% 
            ]
            .join("\n")
        )
    #     })
end

def test_query_errors_on_invalid_symbols()
    # TreeSitterFFI::allocations.record(|| {
        language = get_language("javascript")

        assert_eq!(
            TreeSitterFFI::Query.make(language, "(clas)"),
            TreeSitterFFI::QueryError.new({
                row: 0,
                offset: 1,
                column: 1,
                kind: TreeSitterFFI::QueryErrorKind.NodeType,
                message: "clas".to_string()
            })
        )
        assert_eq!(
            TreeSitterFFI::Query.make(language, "(if_statement (arrayyyyy))"),
            TreeSitterFFI::QueryError.new({
                row: 0,
                offset: 15,
                column: 15,
                kind: TreeSitterFFI::QueryErrorKind.NodeType,
                message: "arrayyyyy".to_string()
            }),
        )
        assert_eq!(
            TreeSitterFFI::Query.make(language, "(if_statement condition: (non_existent3))"),
            TreeSitterFFI::QueryError.new({
                row: 0,
                offset: 26,
                column: 26,
                kind: TreeSitterFFI::QueryErrorKind.NodeType,
                message: "non_existent3".to_string()
            }),
        )
        assert_eq!(
            TreeSitterFFI::Query.make(language, "(if_statement condit: (identifier))"),
            TreeSitterFFI::QueryError.new({
                row: 0,
                offset: 14,
                column: 14,
                kind: TreeSitterFFI::QueryErrorKind.Field,
                message: "condit".to_string()
            }),
        )
        assert_eq!(
            TreeSitterFFI::Query.make(language, "(if_statement conditioning: (identifier))"),
            TreeSitterFFI::QueryError.new({
                row: 0,
                offset: 14,
                column: 14,
                kind: TreeSitterFFI::QueryErrorKind.Field,
                message: "conditioning".to_string()
            })
        )
        assert_eq!(
            TreeSitterFFI::Query.make(language, "(if_statement !alternativ)"),
            TreeSitterFFI::QueryError.new({
                row: 0,
                offset: 15,
                column: 15,
                kind: TreeSitterFFI::QueryErrorKind.Field,
                message: "alternativ".to_string()
            })
        )
        assert_eq!(
            TreeSitterFFI::Query.make(language, "(if_statement !alternatives)"),
            TreeSitterFFI::QueryError.new({
                row: 0,
                offset: 15,
                column: 15,
                kind: TreeSitterFFI::QueryErrorKind.Field,
                message: "alternatives".to_string()
            })
        )
    #     })
end

=begin
def test_query_errors_on_invalid_predicates()
    # TreeSitterFFI::allocations.record(|| {
        language = get_language("javascript")

        assert_eq!(
            TreeSitterFFI::Query.make(language, "((identifier) @id (@id))"),
            TreeSitterFFI::QueryError.new({
                kind: TreeSitterFFI::QueryErrorKind.Syntax,
                row: 0,
                column: 19,
                offset: 19,
                message: [
                    "((identifier) @id (@id))", #
                    "                   ^"
                ]
                .join("\n")
            })
        )
        assert_eq!(
            TreeSitterFFI::Query.make(language, "((identifier) @id (#eq? @id))"),
            TreeSitterFFI::QueryError.new({
                kind: TreeSitterFFI::QueryErrorKind.Predicate,
                row: 0,
                column: 0,
                offset: 0,
                message: "Wrong number of arguments to #eq? predicate. Expected 2, got 1."
                    .to_string()
            })
        )
        assert_eq!(
            TreeSitterFFI::Query.make(language, "((identifier) @id (#eq? @id @ok))"),
            TreeSitterFFI::QueryError.new({
                kind: TreeSitterFFI::QueryErrorKind.Capture,
                row: 0,
                column: 29,
                offset: 29,
                message: "ok".to_string(),
            })
        )
    #     })
end
=end

def test_query_errors_on_impossible_patterns()
    js_lang = get_language("javascript")
    rb_lang = get_language("ruby")

    # TreeSitterFFI::allocations.record(|| {
        assert_eq!(
            TreeSitterFFI::Query.make(
                js_lang,
                "(binary_expression left: (identifier) left: (identifier))"
            ),
            Err(TreeSitterFFI::QueryError.new({
                kind: TreeSitterFFI::QueryErrorKind.Structure,
                row: 0,
                offset: 38,
                column: 38,
                message: [
                    "(binary_expression left: (identifier) left: (identifier))",
                    "                                      ^"
                ]
                .join("\n"),
            }))
        )

        TreeSitterFFI::Query.make(
            js_lang,
            "(function_declaration name: (identifier) (statement_block))",
        )
        assert_eq!(
            TreeSitterFFI::Query.make(js_lang, "(function_declaration name: (statement_block))"),
            Err(TreeSitterFFI::QueryError.new({
                kind: TreeSitterFFI::QueryErrorKind.Structure,
                row: 0,
                offset: 22,
                column: 22,
                message: [
                    "(function_declaration name: (statement_block))",
                    "                      ^",
                ]
                .join("\n")
            }))
        )

        TreeSitterFFI::Query.make(rb_lang, "(call receiver:(call))")
        assert_eq!(
            TreeSitterFFI::Query.make(rb_lang, "(call receiver:(binary))"),
            Err(TreeSitterFFI::QueryError.new({
                kind: TreeSitterFFI::QueryErrorKind.Structure,
                row: 0,
                offset: 6,
                column: 6,
                message: [
                    "(call receiver:(binary))", #
                    "      ^",
                ]
                .join("\n")
            }))
        )

        TreeSitterFFI::Query.make(
            js_lang,
            "[
                (function (identifier))
                (function_declaration (identifier))
                (generator_function_declaration (identifier))
            ]",
        )
        assert_eq!(
            TreeSitterFFI::Query.make(
                js_lang,
                "[
                    (function (identifier))
                    (function_declaration (object))
                    (generator_function_declaration (identifier))
                ]",
            ),
            Err(TreeSitterFFI::QueryError.new({
                kind: TreeSitterFFI::QueryErrorKind.Structure,
                row: 2,
                offset: 88,
                column: 42,
                message: [
                    "                    (function_declaration (object))", #
                    "                                          ^",
                ]
                .join("\n")
            }))
        )

        assert_eq!(
            TreeSitterFFI::Query.make(js_lang, "(identifier (identifier))",),
            Err(TreeSitterFFI::QueryError.new({
                kind: TreeSitterFFI::QueryErrorKind.Structure,
                row: 0,
                offset: 12,
                column: 12,
                message: [
                    "(identifier (identifier))", #
                    "            ^",
                ]
                .join("\n")
            }))
        )
        assert_eq!(
            TreeSitterFFI::Query.make(js_lang, "(true (true))",),
            Err(TreeSitterFFI::QueryError.new({
                kind: TreeSitterFFI::QueryErrorKind.Structure,
                row: 0,
                offset: 6,
                column: 6,
                message: [
                    "(true (true))", #
                    "      ^",
                ]
                .join("\n")
            }))
        )

        TreeSitterFFI::Query.make(
            js_lang,
            "(if_statement
                condition: (parenthesized_expression (_expression) @cond))",
        )

        assert_eq!(
            TreeSitterFFI::Query.make(js_lang, "(if_statement condition: (_expression))",),
            Err(TreeSitterFFI::QueryError.new({
                kind: TreeSitterFFI::QueryErrorKind.Structure,
                row: 0,
                offset: 14,
                column: 14,
                message: [
                    "(if_statement condition: (_expression))", #
                    "              ^",
                ]
                .join("\n")
            }))
        )
    #     })
end

def test_query_verifies_possible_patterns_with_aliased_parent_nodes()
    # TreeSitterFFI::allocations.record(|| {
        ruby = get_language("ruby")

        TreeSitterFFI::Query.make(ruby, "(destructured_parameter (identifier))")

        assert_eq!(
            TreeSitterFFI::Query.make(ruby, "(destructured_parameter (string))",),
            Err(TreeSitterFFI::QueryError.new({
                kind: TreeSitterFFI::QueryErrorKind.Structure,
                row: 0,
                offset: 24,
                column: 24,
                message: [
                    "(destructured_parameter (string))", #
                    "                        ^",
                ]
                .join("\n")
            }))
        )
    #     })
end

def test_query_matches_with_simple_pattern()
    # TreeSitterFFI::allocations.record(|| {
        language = get_language("javascript")
        query = TreeSitterFFI::Query.make(
            language,
            "(function_declaration name: (identifier) @fn-name)",
        )

        assert_query_matches(
            language,
            query,
            "function one() { two(); function three() {} }",
            [
                [0, [["fn-name", "one"]]],
                [0, [["fn-name", "three"]]],
            ],
        )
    #     })
end

def test_query_matches_with_multiple_on_same_root()
    # TreeSitterFFI::allocations.record(|| {
        language = get_language("javascript")
        query = TreeSitterFFI::Query.make(
            language,
            "(class_declaration
                name: (identifier) @the-class-name
                (class_body
                    (method_definition
                        name: (property_identifier) @the-method-name)))",
        )

        assert_query_matches(
            language,
            query,
            "
            class Person {
                # the constructor
                constructor(name) { this.name = name; }

                # the getter
                getFullName() { return this.name; }
            }
            ",
            [
                [
                    0,
                    [
                        ["the-class-name", "Person"],
                        ["the-method-name", "constructor"],
                    ],
                ],
                [
                    0,
                    [
                        ["the-class-name", "Person"],
                        ["the-method-name", "getFullName"],
                    ],
                ],
            ],
        )
    #     })
end

def test_query_matches_with_multiple_patterns_different_roots()
    # TreeSitterFFI::allocations.record(|| {
        language = get_language("javascript")
        query = TreeSitterFFI::Query.make(
            language,
            "
                (function_declaration name:(identifier) @fn-def)
                (call_expression function:(identifier) @fn-ref)
            ",
        )

        assert_query_matches(
            language,
            query,
            "
            function f1() {
                f2(f3());
            }
            ",
            [
                [0, [["fn-def", "f1"]]],
                [1, [["fn-ref", "f2"]]],
                [1, [["fn-ref", "f3"]]],
            ],
        )
    #     })
end

def test_query_matches_with_multiple_patterns_same_root()
    # TreeSitterFFI::allocations.record(|| {
        language = get_language("javascript")
        query = TreeSitterFFI::Query.make(
            language,
            "
              (pair
                key: (property_identifier) @method-def
                value: (function))

              (pair
                key: (property_identifier) @method-def
                value: (arrow_function))
            ",
        )

        assert_query_matches(
            language,
            query,
            "
            a = {
                b: () => { return c; },
                d: function() { return d; }
            };
            ",
            [
                [1, [["method-def", "b"]]],
                [0, [["method-def", "d"]]],
            ],
        )
    #     })
end

def test_query_matches_with_nesting_and_no_fields()
    # TreeSitterFFI::allocations.record(|| {
        language = get_language("javascript")
        query = TreeSitterFFI::Query.make(
            language,
            "
                (array
                    (array
                        (identifier) @x1
                        (identifier) @x2))
            ",
        )

        assert_query_matches(
            language,
            query,
            "
            [[a]];
            [[c, d], [e, f, g, h]];
            [[h], [i]];
            ",
            [
                [0, [["x1", "c"], ["x2", "d"]]],
                [0, [["x1", "e"], ["x2", "f"]]],
                [0, [["x1", "e"], ["x2", "g"]]],
                [0, [["x1", "f"], ["x2", "g"]]],
                [0, [["x1", "e"], ["x2", "h"]]],
                [0, [["x1", "f"], ["x2", "h"]]],
                [0, [["x1", "g"], ["x2", "h"]]],
            ],
        )
    #     })
end

=begin
def test_query_matches_with_many_results()
    # TreeSitterFFI::allocations.record(|| {
        language = get_language("javascript")
        query = TreeSitterFFI::Query.make(language, "(array (identifier) @element)")

        assert_query_matches(
            language,
            query,
            "[hello];\n".repeat(50),
            vec![[0, [["element", "hello"]]]; 50],
        )
    #     })
end
=end

=begin
def test_query_matches_with_many_overlapping_results()
    # TreeSitterFFI::allocations.record(|| {
        language = get_language("javascript")
        query = TreeSitterFFI::Query.make(
            language,
            %q%
            (call_expression
                function: (member_expression
                    property: (property_identifier) @method))
            (call_expression
                function: (identifier) @function)
            ((identifier) @constant
             (#match? @constant "[A-Z\\d_]+"))
            % ,
        )

        count = 1024

        # Deeply nested chained function calls:
        # a
        #    .foo(bar(BAZ))
        #    .foo(bar(BAZ))
        #    .foo(bar(BAZ))
        #    ...
        source = "a".to_string()
        source += "\n  .foo(bar(BAZ))".repeat(count)

#         assert_query_matches(
#             language,
#             query,
#             source,
#             [
#                 [0, [["method", "foo"]]],
#                 [1, [["function", "bar"]]],
#                 [2, [["constant", "BAZ"]]],
#             ]
#             .iter()
#             .cloned()
#             .cycle()
#             .take(3 * count)
#             .TreeSitterFFI::collect.<Vec<_>>(),
#         )
    #     })
end
=end

def test_query_matches_capturing_error_nodes()
    # TreeSitterFFI::allocations.record(|| {
        language = get_language("javascript")
        query = TreeSitterFFI::Query.make(
            language,
            "
            (ERROR (identifier) @the-error-identifier) @the-error
            ",
        )

        assert_query_matches(
            language,
            query,
            "function a(b,, c, d :e:) {}",
            [[0, [["the-error", ":e:"], ["the-error-identifier", "e"]]]],
        )
    #     })
end

def test_query_matches_with_extra_children()
    # TreeSitterFFI::allocations.record(|| {
        language = get_language("ruby")
        query = TreeSitterFFI::Query.make(
            language,
            "
            (program(comment) @top_level_comment)
            (argument_list (heredoc_body) @heredoc_in_args)
            ",
        )

        assert_query_matches(
            language,
            query,
            "
            # top-level
            puts(
                # not-top-level
                <<-IN_ARGS, bar.baz
                HELLO
                IN_ARGS
            )

            puts <<-NOT_IN_ARGS
            NO
            NOT_IN_ARGS
            ",
            [
                [0, [["top_level_comment", "# top-level"]]],
                [
                    1,
                    [[
                        "heredoc_in_args",
                        "\n                HELLO\n                IN_ARGS",
                    ]],
                ],
            ],
        )
    #     })
end

def test_query_matches_with_named_wildcard()
    # TreeSitterFFI::allocations.record(|| {
        language = get_language("javascript")
        query = TreeSitterFFI::Query.make(
            language,
            "
            (return_statement (_) @the-return-value)
            (binary_expression operator: _ @the-operator)
            ",
        )

        source = "return a + b - c;"

        parser = TreeSitterFFI.parser()
        parser.set_language(language)
        tree = parser.parse(source, nil)
        cursor = TreeSitterFFI::QueryCursor.make()
        matches = cursor.matches(query, tree.root_node(), source.as_bytes())

        assert_eq!(
            collect_matches(matches, query, source),
            [
                [0, [["the-return-value", "a + b - c"]]],
                [1, [["the-operator", "+"]]],
                [1, [["the-operator", "-"]]],
            ]
        )
    #     })
end

def test_query_matches_with_wildcard_at_the_root()
    # TreeSitterFFI::allocations.record(|| {
        language = get_language("javascript")
        query = TreeSitterFFI::Query.make(
            language,
            "
            (_
                (comment) @doc
                .
                (function_declaration
                    name: (identifier) @name))
            ",
        )

        assert_query_matches(
            language,
            query,
            "/* one */ var x; /* two */ function y() {} /* three */ class Z {}",
            [[0, [["doc", "/* two */"], ["name", "y"]]]],
        )

        query = TreeSitterFFI::Query.make(
            language,
            "
                (_ (string) @a)
                (_ (number) @b)
                (_ (true) @c)
                (_ (false) @d)
            ",
        )

        assert_query_matches(
            language,
            query,
            "['hi', x(true), {y: false}]",
            [
                [0, [["a", "'hi'"]]],
                [2, [["c", "true"]]],
                [3, [["d", "false"]]],
            ],
        )
    #     })
end

def test_query_matches_with_immediate_siblings()
    # TreeSitterFFI::allocations.record(|| {
        language = get_language("python")

        # The immediate child operator '.' can be used in three similar ways:
        # 1. Before the first child node in a pattern, it means that there cannot be any
        #    named siblings before that child node.
        # 2. After the last child node in a pattern, it means that there cannot be any named
        #    sibling after that child node.
        # 2. Between two child nodes in a pattern, it specifies that there cannot be any
        #    named siblings between those two child snodes.
        query = TreeSitterFFI::Query.make(
            language,
            "
            (dotted_name
                (identifier) @parent
                .
                (identifier) @child)
            (dotted_name
                (identifier) @last-child
                .)
            (list
                .
                (_) @first-element)
            ",
        )

        assert_query_matches(
            language,
            query,
            "import a.b.c.d; return [w, [1, y], z]",
            [
                [0, [["parent", "a"], ["child", "b"]]],
                [0, [["parent", "b"], ["child", "c"]]],
                [0, [["parent", "c"], ["child", "d"]]],
                [1, [["last-child", "d"]]],
                [2, [["first-element", "w"]]],
                [2, [["first-element", "1"]]],
            ],
        )

        query = TreeSitterFFI::Query.make(
            language,
            "
            (block . (_) @first-stmt)
            (block (_) @stmt)
            (block (_) @last-stmt .)
            ",
        )

        assert_query_matches(
            language,
            query,
            "
            if a:
                b()
                c()
                if d(): e(); f()
                g()
            ",
            [
                [0, [["first-stmt", "b()"]]],
                [1, [["stmt", "b()"]]],
                [1, [["stmt", "c()"]]],
                [1, [["stmt", "if d(): e(); f()"]]],
                [0, [["first-stmt", "e()"]]],
                [1, [["stmt", "e()"]]],
                [1, [["stmt", "f()"]]],
                [2, [["last-stmt", "f()"]]],
                [1, [["stmt", "g()"]]],
                [2, [["last-stmt", "g()"]]],
            ],
        )
    #     })
end

def test_query_matches_with_last_named_child()
    # TreeSitterFFI::allocations.record(|| {
        language = get_language("c")
        query = TreeSitterFFI::Query.make(
            language,
            "(compound_statement
                (_)
                (_)
                (expression_statement
                    (identifier) @last_id) .)",
        )
        assert_query_matches(
            language,
            query,
            "
            void one() { a; b; c; }
            void two() { d; e; }
            void three() { f; g; h; i; }
            ",
            [[0, [["last_id", "c"]]], [0, [["last_id", "i"]]]],
        )
    #     })
end

def test_query_matches_with_negated_fields()
    # TreeSitterFFI::allocations.record(|| {
        language = get_language("javascript")
        query = TreeSitterFFI::Query.make(
            language,
            "
            (import_specifier
                !alias
                name: (identifier) @import_name)

            (export_specifier
                !alias
                name: (identifier) @export_name)

            (export_statement
                !decorator
                !source
                (_) @exported)

            ; This negated field list is an extension of a previous
            ; negated field list. The order of the children and negated
            ; fields doesn't matter.
            (export_statement
                !decorator
                !source
                (_) @exported_expr
                !declaration)

            ; This negated field list is a prefix of a previous
            ; negated field list.
            (export_statement
                !decorator
                (_) @export_child .)
            ",
        )
        assert_query_matches(
            language,
            query,
            "
            import {a as b, c} from 'p1';
            export {g, h as i} from 'p2';

            @foo
            export default 1;

            export var j = 1;

            export default k;
            ",
            [
                [0, [["import_name", "c"]]],
                [1, [["export_name", "g"]]],
                [4, [["export_child", "'p2'"]]],
                [2, [["exported", "var j = 1;"]]],
                [4, [["export_child", "var j = 1;"]]],
                [2, [["exported", "k"]]],
                [3, [["exported_expr", "k"]]],
                [4, [["export_child", "k"]]],
            ],
        )
    #     })
end

def test_query_matches_with_field_at_root()
    # TreeSitterFFI::allocations.record(|| {
        language = get_language("javascript")
        query = TreeSitterFFI::Query.make(language, "name: (identifier) @name")
        assert_query_matches(
            language,
            query,
            "
            a();
            function b() {}
            class c extends d {}
            ",
            [[0, [["name", "b"]]], [0, [["name", "c"]]]],
        )
    #     })
end

def test_query_matches_with_repeated_leaf_nodes()
    # TreeSitterFFI::allocations.record(|| {
        language = get_language("javascript")

        query = TreeSitterFFI::Query.make(
            language,
            "
            (
                (comment)+ @doc
                .
                (class_declaration
                    name: (identifier) @name)
            )

            (
                (comment)+ @doc
                .
                (function_declaration
                    name: (identifier) @name)
            )
            ",
        )

        assert_query_matches(
            language,
            query,
            "
            # one
            # two
            a();

            # three
            {
                # four
                # five
                # six
                class B {}

                # seven
                c();

                # eight
                function d() {}
            }
            ",
            [
                [
                    0,
                    [
                        ["doc", "# four"],
                        ["doc", "# five"],
                        ["doc", "# six"],
                        ["name", "B"],
                    ],
                ],
                [1, [["doc", "# eight"], ["name", "d"]]],
            ],
        )
    #     })
end

def test_query_matches_with_optional_nodes_inside_of_repetitions()
    # TreeSitterFFI::allocations.record(|| {
        language = get_language("javascript")
        query = TreeSitterFFI::Query.make(language, %q%(array (","? (number) @num)+)% )

        assert_query_matches(
            language,
            query,
            %q%
            var a = [1, 2, 3, 4]
            % ,
            [[
                0,
                [["num", "1"], ["num", "2"], ["num", "3"], ["num", "4"]],
            ]],
        )
    #     })
end

def test_query_matches_with_top_level_repetitions()
    # TreeSitterFFI::allocations.record(|| {
        language = get_language("javascript")
        query = TreeSitterFFI::Query.make(
            language,
            %q%
            (comment)+ @doc
            % ,
        )

        assert_query_matches(
            language,
            query,
            %q%
            # a
            # b
            # c

            d()

            # e
            % ,
            [
                [0, [["doc", "# a"], ["doc", "// b"], ["doc", "// c"]]],
                [0, [["doc", "# e"]]],
            ],
        )
    #     })
end

def test_query_matches_with_non_terminal_repetitions_within_root()
    # TreeSitterFFI::allocations.record(|| {
        language = get_language("javascript")
        query = TreeSitterFFI::Query.make(language, "(_ (expression_statement (identifier) @id)+)")

        assert_query_matches(
            language,
            query,
            %q%
            a;
            b;
            c;
            % ,
            [[0, [["id", "a"], ["id", "b"], ["id", "c"]]]],
        )
    #     })
end

def test_query_matches_with_nested_repetitions()
    # TreeSitterFFI::allocations.record(|| {
        language = get_language("javascript")
        query = TreeSitterFFI::Query.make(
            language,
            %q%
            (variable_declaration
                (","? (variable_declarator name: (identifier) @x))+)+
            % ,
        )

        assert_query_matches(
            language,
            query,
            %q%
            var a = b, c, d
            var e, f

            # more
            var g
            % ,
            [
                [
                    0,
                    [["x", "a"], ["x", "c"], ["x", "d"], ["x", "e"], ["x", "f"]],
                ],
                [0, [["x", "g"]]],
            ],
        )
    #     })
end

=begin
def test_query_matches_with_multiple_repetition_patterns_that_intersect_other_pattern()
    # TreeSitterFFI::allocations.record(|| {
        language = get_language("javascript")

        # When this query sees a comment, it must keep track of several potential
        # matches: up to two for each pattern that begins with a comment.
        query = TreeSitterFFI::Query.make(
            language,
            %q%
            (call_expression
                function: (member_expression
                    property: (property_identifier) @name)) @ref.method

            ((comment)* @doc (function_declaration))
            ((comment)* @doc (generator_function_declaration))
            ((comment)* @doc (class_declaration))
            ((comment)* @doc (lexical_declaration))
            ((comment)* @doc (variable_declaration))
            ((comment)* @doc (method_definition))

            (comment) @comment
            % ,
        )

        # Here, a series of comments occurs in the middle of a match of the first
        # pattern. To avoid exceeding the storage limits and discarding that outer
        # match, the comment-related matches need to be managed efficiently.
        source = format!(
            "theObject\n{}\n.theMethod()",
            "  # the comment\n".repeat(64)
        )

#         assert_query_matches(
#             language,
#             query,
#             source,
#             vec![[7, [["comment", "# the comment"]]]; 64]
#                 .into_iter()
#                 .chain(vec![(
#                     0,
#                     vec![("ref.method", source.as_str()), ("name", "theMethod")],
#                 )])
#                 .TreeSitterFFI::collect.<Vec<_>>(),
#         )
    #     })
end
=end

def test_query_matches_with_trailing_repetitions_of_last_child()
    # TreeSitterFFI::allocations.record(|| {
        language = get_language("javascript")

        query = TreeSitterFFI::Query.make(
            language,
            "
            (unary_expression (primary_expression)+ @operand)
            ",
        )

        assert_query_matches(
            language,
            query,
            "
            a = typeof (!b && ~c);
            ",
            [
                [0, [["operand", "b"]]],
                [0, [["operand", "c"]]],
                [0, [["operand", "(!b && ~c)"]]],
            ],
        )
    #     })
end

def test_query_matches_with_leading_zero_or_more_repeated_leaf_nodes()
    # TreeSitterFFI::allocations.record(|| {
        language = get_language("javascript")

        query = TreeSitterFFI::Query.make(
            language,
            "
            (
                (comment)* @doc
                .
                (function_declaration
                    name: (identifier) @name)
            )
            ",
        )

        assert_query_matches(
            language,
            query,
            "
            function a() {
                # one
                var b;

                function c() {}

                # two
                # three
                var d;

                # four
                # five
                function e() {

                }
            }

            # six
            ",
            [
                [0, [["name", "a"]]],
                [0, [["name", "c"]]],
                [
                    0,
                    [["doc", "# four"], ["doc", "// five"], ["name", "e"]],
                ],
            ],
        )
    #     })
end

def test_query_matches_with_trailing_optional_nodes()
    # TreeSitterFFI::allocations.record(|| {
        language = get_language("javascript")

        query = TreeSitterFFI::Query.make(
            language,
            "
            (class_declaration
                name: (identifier) @class
                (class_heritage
                  (identifier) @superclass)?)
            ",
        )

        assert_query_matches(language, query, "class A {}", [[0, [["class", "A"]]]])

        assert_query_matches(
            language,
            query,
            "
            class A {}
            class B extends C {}
            class D extends (E.F) {}
            ",
            [
                [0, [["class", "A"]]],
                [0, [["class", "B"], ["superclass", "C"]]],
                [0, [["class", "D"]]],
            ],
        )
    #     })
end

def test_query_matches_with_nested_optional_nodes()
    # TreeSitterFFI::allocations.record(|| {
        language = get_language("javascript")

        # A function call, optionally containing a function call, which optionally contains a number
        query = TreeSitterFFI::Query.make(
            language,
            "
            (call_expression
                function: (identifier) @outer-fn
                arguments: (arguments
                    (call_expression
                        function: (identifier) @inner-fn
                        arguments: (arguments
                            (number)? @num))?))
            ",
        )

        assert_query_matches(
            language,
            query,
            %q%
            a(b, c(), d(null, 1, 2))
            e()
            f(g())
            % ,
            [
                [0, [["outer-fn", "a"], ["inner-fn", "c"]]],
                [0, [["outer-fn", "c"]]],
                [0, [["outer-fn", "a"], ["inner-fn", "d"], ["num", "1"]]],
                [0, [["outer-fn", "a"], ["inner-fn", "d"], ["num", "2"]]],
                [0, [["outer-fn", "d"]]],
                [0, [["outer-fn", "e"]]],
                [0, [["outer-fn", "f"], ["inner-fn", "g"]]],
                [0, [["outer-fn", "g"]]],
            ],
        )
    #     })
end

def test_query_matches_with_repeated_internal_nodes()
    # TreeSitterFFI::allocations.record(|| {
        language = get_language("javascript")
        query = TreeSitterFFI::Query.make(
            language,
            "
            (_
                (method_definition
                    (decorator (identifier) @deco)+
                    name: (property_identifier) @name))
            ",
        )

        assert_query_matches(
            language,
            query,
            "
            class A {
                @c
                @d
                e() {}
            }
            ",
            [[0, [["deco", "c"], ["deco", "d"], ["name", "e"]]]],
        )
    #     })
end

def test_query_matches_with_simple_alternatives()
    # TreeSitterFFI::allocations.record(|| {
        language = get_language("javascript")
        query = TreeSitterFFI::Query.make(
            language,
            "
            (pair
                key: [(property_identifier) (string)] @key
                value: [(function) @val1 (arrow_function) @val2])
            ",
        )

        assert_query_matches(
            language,
            query,
            "
            a = {
                b: c,
                'd': e => f,
                g: {
                    h: function i() {},
                    'x': null,
                    j: _ => k
                },
                'l': function m() {},
            };
            ",
            [
                [0, [["key", "'d'"], ["val2", "e => f"]]],
                [0, [["key", "h"], ["val1", "function i() {}"]]],
                [0, [["key", "j"], ["val2", "_ => k"]]],
                [0, [["key", "'l'"], ["val1", "function m() {}"]]],
            ],
        )
    #     })
end

def test_query_matches_with_alternatives_in_repetitions()
    # TreeSitterFFI::allocations.record(|| {
        language = get_language("javascript")
        query = TreeSitterFFI::Query.make(
            language,
            %q%
            (array
                [(identifier) (string)] @el
                .
                (
                    ","
                    .
                    [(identifier) (string)] @el
                )*)
            % ,
        )

        assert_query_matches(
            language,
            query,
            "
            a = [b, 'c', d, 1, e, 'f', 'g', h];
            ",
            [
                [0, [["el", "b"], ["el", "'c'"], ["el", "d"]]],
                [
                    0,
                    [["el", "e"], ["el", "'f'"], ["el", "'g'"], ["el", "h"]],
                ],
            ],
        )
    #     })
end

def test_query_matches_with_alternatives_at_root()
    # TreeSitterFFI::allocations.record(|| {
        language = get_language("javascript")
        query = TreeSitterFFI::Query.make(
            language,
            %q%
            [
                "if"
                "else"
                "function"
                "throw"
                "return"
            ] @keyword
            % ,
        )

        assert_query_matches(
            language,
            query,
            "
            function a(b, c, d) {
                if (b) {
                    return c;
                } else {
                    throw d;
                }
            }
            ",
            [
                [0, [["keyword", "function"]]],
                [0, [["keyword", "if"]]],
                [0, [["keyword", "return"]]],
                [0, [["keyword", "else"]]],
                [0, [["keyword", "throw"]]],
            ],
        )
    #     })
end

def test_query_matches_with_alternatives_under_fields()
    # TreeSitterFFI::allocations.record(|| {
        language = get_language("javascript")
        query = TreeSitterFFI::Query.make(
            language,
            %q%
            (assignment_expression
                left: [
                    (identifier) @variable
                    (member_expression property: (property_identifier) @variable)
                ])
            % ,
        )

        assert_query_matches(
            language,
            query,
            "
            a = b;
            b = c.d;
            e.f = g;
            h.i = j.k;
            ",
            [
                [0, [["variable", "a"]]],
                [0, [["variable", "b"]]],
                [0, [["variable", "f"]]],
                [0, [["variable", "i"]]],
            ],
        )
    #     })
end

def test_query_matches_in_language_with_simple_aliases()
    # TreeSitterFFI::allocations.record(|| {
        language = get_language("html")

        # HTML uses different tokens to track start tags names, end
        # tag names, script tag names, and style tag names. All of
        # these tokens are aliased to `tag_name`.
        query = TreeSitterFFI::Query.make(language, "(tag_name) @tag")

        assert_query_matches(
            language,
            query,
            "
            <div>
                <script>hi</script>
                <style>hi</style>
            </div>
            ",
            [
                [0, [["tag", "div"]]],
                [0, [["tag", "script"]]],
                [0, [["tag", "script"]]],
                [0, [["tag", "style"]]],
                [0, [["tag", "style"]]],
                [0, [["tag", "div"]]],
            ],
        )
    #     })
end

def test_query_matches_with_different_tokens_with_the_same_string_value()
    # TreeSitterFFI::allocations.record(|| {
        # In Rust, there are two '<' tokens: one for the binary operator,
        # and one with higher precedence for generics.
        language = get_language("rust")
        query = TreeSitterFFI::Query.make(
            language,
            %q%
                "<" @less
                ">" @greater
                % ,
        )

        assert_query_matches(
            language,
            query,
            "const A: B<C> = d < e || f > g;",
            [
                [0, [["less", "<"]]],
                [1, [["greater", ">"]]],
                [0, [["less", "<"]]],
                [1, [["greater", ">"]]],
            ],
        )
    #     })
end

=begin
def test_query_matches_with_too_many_permutations_to_track()
    # TreeSitterFFI::allocations.record(|| {
        language = get_language("javascript")
        query = TreeSitterFFI::Query.make(
            language,
            "
            (array (identifier) @pre (identifier) @post)
        ",
        )

        source = "hello, ".repeat(50)
        source.insert(0, '[')
        source.push_str("];")

        parser = TreeSitterFFI.parser()
        parser.set_language(language)
        tree = parser.parse(source, nil)
        cursor = TreeSitterFFI::QueryCursor.make()
        cursor.set_match_limit(32)
        matches = cursor.matches(query, tree.root_node(), source.as_bytes())

        # For this pathological query, some match permutations will be dropped.
        # Just check that a subset of the results are returned, and crash or
        # leak occurs.
        assert_eq!(
            collect_matches(matches, query, source.as_str())[0],
            [0, [["pre", "hello"], ["post", "hello"]]],
        )
        assert_eq!(cursor.did_exceed_match_limit(), true)
    #     })
end
=end

=begin
def test_query_matches_with_alternatives_and_too_many_permutations_to_track()
    # TreeSitterFFI::allocations.record(|| {
        language = get_language("javascript")
        query = TreeSitterFFI::Query.make(
            language,
            "
            (
                (comment) @doc
                ; not immediate
                (class_declaration) @class
            )

            (call_expression
                function: [
                    (identifier) @function
                    (member_expression property: (property_identifier) @method)
                ])
            ",
        )

        source = "/* hi */ a.b(); ".repeat(50)

        parser = TreeSitterFFI.parser()
        parser.set_language(language)
        tree = parser.parse(source, nil)
        cursor = TreeSitterFFI::QueryCursor.make()
        cursor.set_match_limit(32)
        matches = cursor.matches(query, tree.root_node(), source.as_bytes())

        assert_eq!(
            collect_matches(matches, query, source.as_str()),
            vec![[1, [["method", "b"]]]; 50],
        )
        assert_eq!(cursor.did_exceed_match_limit(), true)
    #     })
end
=end

def test_query_matches_with_anonymous_tokens()
    # TreeSitterFFI::allocations.record(|| {
        language = get_language("javascript")
        query = TreeSitterFFI::Query.make(
            language,
            %q%
            ";" @punctuation
            "&&" @operator
            "\"" @quote
            % ,
        )

        assert_query_matches(
            language,
            query,
            %q%foo(a && "b");% ,
            [
                [1, [["operator", "&&"]]],
                [2, [["quote", "\""]]],
                [2, [["quote", "\""]]],
                [0, [["punctuation", ";"]]],
            ],
        )
    #     })
end

def test_query_matches_with_supertypes()
    # TreeSitterFFI::allocations.record(|| {
        language = get_language("python")
        query = TreeSitterFFI::Query.make(
            language,
            %q%
            (argument_list (expression) @arg)

            (keyword_argument
                value: (expression) @kw_arg)

            (assignment
              left: (identifier) @var_def)

            (primary_expression/identifier) @var_ref
            % ,
        )

        assert_query_matches(
            language,
            query,
            "
                a = b.c(
                    [d],
                    # a comment
                    e=f
                )
            ",
            [
                [2, [["var_def", "a"]]],
                [3, [["var_ref", "b"]]],
                [0, [["arg", "[d]"]]],
                [3, [["var_ref", "d"]]],
                [1, [["kw_arg", "f"]]],
                [3, [["var_ref", "f"]]],
            ],
        )
    #     })
end

def test_query_matches_within_byte_range()
    # TreeSitterFFI::allocations.record(|| {
        language = get_language("javascript")
        query = TreeSitterFFI::Query.make(language, "(identifier) @element")

        source = "[a, b, c, d, e, f, g]"

        parser = TreeSitterFFI.parser()
        parser.set_language(language)
        tree = parser.parse(source, nil)

        cursor = TreeSitterFFI::QueryCursor.make()

        matches =
            cursor
                .set_byte_range(0...8)
                .matches(query, tree.root_node(), source.as_bytes())

        assert_eq!(
            collect_matches(matches, query, source),
            [
                [0, [["element", "a"]]],
                [0, [["element", "b"]]],
                [0, [["element", "c"]]],
            ]
        )

        matches =
            cursor
                .set_byte_range(5...15)
                .matches(query, tree.root_node(), source.as_bytes())

        assert_eq!(
            collect_matches(matches, query, source),
            [
                [0, [["element", "c"]]],
                [0, [["element", "d"]]],
                [0, [["element", "e"]]],
            ]
        )

        matches =
            cursor
                .set_byte_range(12...0)
                .matches(query, tree.root_node(), source.as_bytes())

        assert_eq!(
            collect_matches(matches, query, source),
            [
                [0, [["element", "e"]]],
                [0, [["element", "f"]]],
                [0, [["element", "g"]]],
            ]
        )
    #     })
end

=begin
def test_query_matches_within_point_range()
    # TreeSitterFFI::allocations.record(|| {
        language = get_language("javascript")
        query = TreeSitterFFI::Query.make(language, "(identifier) @element")

        source = "[a, b,\n c, d,\n e, f,\n g]"

        parser = TreeSitterFFI.parser()
        parser.set_language(language)
        tree = parser.parse(source, nil)

        cursor = TreeSitterFFI::QueryCursor.make()

        matches = cursor
            .set_point_range(TreeSitterFFI::Point.new(0, 0)..TreeSitterFFI::Point.new(1, 3))
            .matches(query, tree.root_node(), source.as_bytes())

        assert_eq!(
            collect_matches(matches, query, source),
            [
                [0, [["element", "a"]]],
                [0, [["element", "b"]]],
                [0, [["element", "c"]]],
            ]
        )

        matches = cursor
            .set_point_range(TreeSitterFFI::Point.new(1, 0)..TreeSitterFFI::Point.new(2, 3))
            .matches(query, tree.root_node(), source.as_bytes())

        assert_eq!(
            collect_matches(matches, query, source),
            [
                [0, [["element", "c"]]],
                [0, [["element", "d"]]],
                [0, [["element", "e"]]],
            ]
        )

        matches = cursor
            .set_point_range(TreeSitterFFI::Point.new(2, 1)..TreeSitterFFI::Point.new(0, 0))
            .matches(query, tree.root_node(), source.as_bytes())

        assert_eq!(
            collect_matches(matches, query, source),
            [
                [0, [["element", "e"]]],
                [0, [["element", "f"]]],
                [0, [["element", "g"]]],
            ]
        )
    #     })
end
=end

def test_query_captures_within_byte_range()
    # TreeSitterFFI::allocations.record(|| {
        language = get_language("c")
        query = TreeSitterFFI::Query.make(
            language,
            "
            (call_expression
                function: (identifier) @function
                arguments: (argument_list (string_literal) @string.arg))

            (string_literal) @string
           ",
        )

        source = %q%DEFUN ("safe-length", Fsafe_length, Ssafe_length, 1, 1, 0)% 

        parser = TreeSitterFFI.parser()
        parser.set_language(language)
        tree = parser.parse(source, nil)

        cursor = TreeSitterFFI::QueryCursor.make()
        captures =
            cursor
                .set_byte_range(3...27)
                .captures(query, tree.root_node(), source.as_bytes())

        assert_eq!(
            collect_captures(captures, query, source),
            [
                ["function", "DEFUN"],
                ["string.arg", "\"safe-length\""],
                ["string", "\"safe-length\""],
            ]
        )
    #     })
end

def test_query_matches_with_unrooted_patterns_intersecting_byte_range()
    # TreeSitterFFI::allocations.record(|| {
        language = get_language("rust")
        query = TreeSitterFFI::Query.make(
            language,
            %q%
            ("{" @left "}" @right)
            ("<" @left ">" @right)
            % ,
        )

        source = "mod a { fn a<B: C, D: E>(f: B) { g(f) } }"

        parser = TreeSitterFFI.parser()
        parser.set_language(language)
        tree = parser.parse(source, nil)
        cursor = TreeSitterFFI::QueryCursor.make()

        # within the type parameter list
        offset = source.index("D: E>")
        matches = cursor.set_byte_range(offset..offset).matches(
            query,
            tree.root_node(),
            source.as_bytes(),
        )
        assert_eq!(
            collect_matches(matches, query, source),
            [
                [1, [["left", "<"], ["right", ">"]]],
                [0, [["left", "{"], ["right", "}"]]],
            ]
        )

        # from within the type parameter list to within the function body
        start_offset = source.index("D: E>")
        end_offset = source.index("g(f)")
        matches = cursor.set_byte_range(start_offset..end_offset).matches(
            query,
            tree.root_node(),
            source.as_bytes(),
        )
        assert_eq!(
            collect_matches(matches, query, source),
            [
                [1, [["left", "<"], ["right", ">"]]],
                [0, [["left", "{"], ["right", "}"]]],
                [0, [["left", "{"], ["right", "}"]]],
            ]
        )
    #     })
end

=begin
def test_query_captures_within_byte_range_assigned_after_iterating()
    # TreeSitterFFI::allocations.record(|| {
        language = get_language("rust")
        query = TreeSitterFFI::Query.make(
            language,
            %q%
            (function_item
                name: (identifier) @fn_name)

            (mod_item
                name: (identifier) @mod_name
                body: (declaration_list
                    "{" @lbrace
                    "}" @rbrace))

            ; functions that return Result<()>
            ((function_item
                return_type: (generic_type
                    type: (type_identifier) @result
                    type_arguments: (type_arguments
                        (unit_type)))
                body: _ @fallible_fn_body)
             (#eq? @result "Result"))
            % ,
        )
        source = "
        mod m1 {
            mod m2 {
                fn f1() -> Option<()> { (()) }
            }
            fn f2() -> Result<()> { Ok(()) }
            fn f3() {}
        }
        "

        parser = TreeSitterFFI.parser()
        parser.set_language(language)
        tree = parser.parse(source, nil)
        cursor = TreeSitterFFI::QueryCursor.make()
        captures = cursor.captures(query, tree.root_node(), source.as_bytes())

#         # Retrieve some captures
#         results = TreeSitterFFI::Vec.new()
        for (mat, capture_ix) in captures.by_ref().take(5) {
            capture = mat.captures[capture_ix as usize]
            results.push((
                query.capture_names()[capture.index as usize].as_str(),
                source[capture.node.byte_range()],
            ))
        }
        assert_eq!(
            results,
            [
                ["mod_name", "m1"],
                ["lbrace", "{"],
                ["mod_name", "m2"],
                ["lbrace", "{"],
                ["fn_name", "f1"],
            ]
        )

        # Advance to a range that only partially intersects some matches.
        # Captures from these matches are reported, but only those that
        # intersect the range.
        results.clear()
        captures.set_byte_range(source.index("Ok")..source.len())
        for (mat, capture_ix) in captures {
            capture = mat.captures[capture_ix as usize]
            results.push((
                query.capture_names()[capture.index as usize].as_str(),
                source[capture.node.byte_range()],
            ))
        }
        assert_eq!(
            results,
            [
                ["fallible_fn_body", "{ Ok(()) }"],
                ["fn_name", "f3"],
                ["rbrace", "}"]
            ]
        )
    #     })
end
=end

def test_query_matches_different_queries_same_cursor()
    # TreeSitterFFI::allocations.record(|| {
        language = get_language("javascript")
        query1 = TreeSitterFFI::Query.make(
            language,
            "
            (array (identifier) @id1)
        ",
        )
        query2 = TreeSitterFFI::Query.make(
            language,
            "
            (array (identifier) @id1)
            (pair (identifier) @id2)
        ",
        )
        query3 = TreeSitterFFI::Query.make(
            language,
            "
            (array (identifier) @id1)
            (pair (identifier) @id2)
            (parenthesized_expression (identifier) @id3)
        ",
        )

        source = "[a, {b: b}, (c)];"

        parser = TreeSitterFFI.parser()
        cursor = TreeSitterFFI::QueryCursor.make()

        parser.set_language(language)
        tree = parser.parse(source, nil)

        matches = cursor.matches(query1, tree.root_node(), source.as_bytes())
        assert_eq!(
            collect_matches(matches, query1, source),
            [[0, [["id1", "a"]]],]
        )

        matches = cursor.matches(query3, tree.root_node(), source.as_bytes())
        assert_eq!(
            collect_matches(matches, query3, source),
            [
                [0, [["id1", "a"]]],
                [1, [["id2", "b"]]],
                [2, [["id3", "c"]]],
            ]
        )

        matches = cursor.matches(query2, tree.root_node(), source.as_bytes())
        assert_eq!(
            collect_matches(matches, query2, source),
            [[0, [["id1", "a"]]], [1, [["id2", "b"]]],]
        )
    #     })
end

=begin
def test_query_matches_with_multiple_captures_on_a_node()
    # TreeSitterFFI::allocations.record(|| {
        language = get_language("javascript")
        query = TreeSitterFFI::Query.make(
            language,
            "(function_declaration
                (identifier) @name1 @name2 @name3
                (statement_block) @body1 @body2)",
        )

        source = "function foo() { return 1; }"
        parser = TreeSitterFFI.parser()
        cursor = TreeSitterFFI::QueryCursor.make()

        parser.set_language(language)
        tree = parser.parse(source, nil)

        matches = cursor.matches(query, tree.root_node(), source.as_bytes())
        assert_eq!(
            collect_matches(matches, query, source),
            [[
                0,
                [
                    ["name1", "foo"],
                    ["name2", "foo"],
                    ["name3", "foo"],
                    ["body1", "{ return 1; }"],
                    ["body2", "{ return 1; }"],
                ]
            ],]
        )

        # disabling captures still works when there are multiple captures on a
        # single node.
        query.disable_capture("name2")
        matches = cursor.matches(query, tree.root_node(), source.as_bytes())
        assert_eq!(
            collect_matches(matches, query, source),
            [[
                0,
                [
                    ["name1", "foo"],
                    ["name3", "foo"],
                    ["body1", "{ return 1; }"],
                    ["body2", "{ return 1; }"],
                ]
            ],]
        )
    #     })
end
=end

=begin
def test_query_matches_with_captured_wildcard_at_root()
    # TreeSitterFFI::allocations.record(|| {
        language = get_language("python")
        query = TreeSitterFFI::Query.make(
            language,
            "
            ; captured wildcard at the root
            (_ [
                (except_clause (block) @block)
                (finally_clause (block) @block)
            ]) @stmt

            [
                (while_statement (block) @block)
                (if_statement (block) @block)

                ; captured wildcard at the root within an alternation
                (_ [
                    (else_clause (block) @block)
                    (elif_clause (block) @block)
                ])

                (try_statement (block) @block)
                (for_statement (block) @block)
            ] @stmt
            ",
        )

        source = "
        for i in j:
            while True:
                if a:
                    print b
                elif c:
                    print d
                else:
                    try:
                        print f
                    except:
                        print g
                    finally:
                        print h
            else:
                print i
        "
        .trim()

        parser = TreeSitterFFI.parser()
        cursor = TreeSitterFFI::QueryCursor.make()
        parser.set_language(language)
        tree = parser.parse(source, nil)

#         match_capture_names_and_rows = cursor
#             .matches(query, tree.root_node(), source.as_bytes())
#             .map(|m| {
#                 m.captures
#                     .iter()
#                     .map(|c| {
#                         (
#                             query.capture_names()[c.index as usize].as_str(),
#                             c.node.type(),
#                             c.node.start_point().row,
#                         )
#                     })
#                     .TreeSitterFFI::collect.<Vec<_>>()
#             })
#             .TreeSitterFFI::collect.<Vec<_>>()

        assert_eq!(
            match_capture_names_and_rows,
            [
                vec![("stmt", "for_statement", 0), ("block", "block", 1)],
                vec![("stmt", "while_statement", 1), ("block", "block", 2)],
                vec![("stmt", "if_statement", 2), ("block", "block", 3)],
                vec![("stmt", "if_statement", 2), ("block", "block", 5)],
                vec![("stmt", "if_statement", 2), ("block", "block", 7)],
                vec![("stmt", "try_statement", 7), ("block", "block", 8)],
                vec![("stmt", "try_statement", 7), ("block", "block", 10)],
                vec![("stmt", "try_statement", 7), ("block", "block", 12)],
                vec![("stmt", "while_statement", 1), ("block", "block", 14)],
            ]
        )
    #     })
end
=end

def test_query_matches_with_no_captures()
    # TreeSitterFFI::allocations.record(|| {
        language = get_language("javascript")
        query = TreeSitterFFI::Query.make(
            language,
            %q%
            (identifier)
            (string) @s
            % ,
        )

        assert_query_matches(
            language,
            query,
            "
            a = 'hi';
            b = 'bye';
            ",
            [
                [0, []],
                [1, [["s", "'hi'"]]],
                [0, []],
                [1, [["s", "'bye'"]]],
            ],
        )
    #     })
end

def test_query_matches_with_repeated_fields()
    # TreeSitterFFI::allocations.record(|| {
        language = get_language("c")
        query = TreeSitterFFI::Query.make(
            language,
            "(field_declaration declarator: (field_identifier) @field)",
        )

        assert_query_matches(
            language,
            query,
            "
            struct S {
                int a, b, c;
            };
            ",
            [
                [0, [["field", "a"]]],
                [0, [["field", "b"]]],
                [0, [["field", "c"]]],
            ],
        )
    #     })
end

def test_query_matches_with_deeply_nested_patterns_with_fields()
    # TreeSitterFFI::allocations.record(|| {
        language = get_language("python")
        query = TreeSitterFFI::Query.make(
            language,
            "
            (call
                function: (_) @func
                arguments: (_) @args)
            (call
                function: (attribute
                    object: (_) @receiver
                    attribute: (identifier) @method)
                arguments: (argument_list))

            ; These don't match anything, but they require additional
            ; states to keep track of their captures.
            (call
                function: (_) @fn
                arguments: (argument_list
                    (keyword_argument
                        name: (identifier) @name
                        value: (_) @val) @arg) @args) @call
            (call
                function: (identifier) @fn
                (#eq? @fn \"super\")) @super_call
            ",
        )

        assert_query_matches(
            language,
            query,
            "
            a(1).b(2).c(3).d(4).e(5).f(6).g(7).h(8)
            ",
            [
                [0, [["func", "a"], ["args", "(1)"]]],
                [0, [["func", "a(1).b"], ["args", "(2)"]]],
                [1, [["receiver", "a(1)"], ["method", "b"]]],
                [0, [["func", "a(1).b(2).c"], ["args", "(3)"]]],
                [1, [["receiver", "a(1).b(2)"], ["method", "c"]]],
                [0, [["func", "a(1).b(2).c(3).d"], ["args", "(4)"]]],
                [1, [["receiver", "a(1).b(2).c(3)"], ["method", "d"]]],
                [0, [["func", "a(1).b(2).c(3).d(4).e"], ["args", "(5)"]]],
                [
                    1,
                    [["receiver", "a(1).b(2).c(3).d(4)"], ["method", "e"]],
                ],
                [
                    0,
                    [["func", "a(1).b(2).c(3).d(4).e(5).f"], ["args", "(6)"]],
                ],
                [
                    1,
                    [["receiver", "a(1).b(2).c(3).d(4).e(5)"], ["method", "f"]],
                ],
                [
                    0,
                    [["func", "a(1).b(2).c(3).d(4).e(5).f(6).g"], ["args", "(7)"]],
                ],
                [
                    1,
                    [
                        ["receiver", "a(1).b(2).c(3).d(4).e(5).f(6)"],
                        ["method", "g"],
                    ],
                ],
                [
                    0,
                    [
                        ["func", "a(1).b(2).c(3).d(4).e(5).f(6).g(7).h"],
                        ["args", "(8)"],
                    ],
                ],
                [
                    1,
                    [
                        ["receiver", "a(1).b(2).c(3).d(4).e(5).f(6).g(7)"],
                        ["method", "h"],
                    ],
                ],
            ],
        )
    #     })
end

def test_query_matches_with_indefinite_step_containing_no_captures()
    # TreeSitterFFI::allocations.record(|| {
        # This pattern depends on the field declarations within the
        # struct's body, but doesn't capture anything within the body.
        # It demonstrates that internally, state-splitting needs to occur
        # for each field declaration within the body, in order to avoid
        # prematurely failing if the first field does not match.
        #
        # https://github.com/tree-sitter/tree-sitter/issues/937
        language = get_language("c")
        query = TreeSitterFFI::Query.make(
            language,
            "(struct_specifier
                name: (type_identifier) @name
                body: (field_declaration_list
                    (field_declaration
                        type: (union_specifier))))",
        )

        assert_query_matches(
            language,
            query,
            "
            struct LacksUnionField {
                int a;
                struct {
                    B c;
                } d;
                G *h;
            };

            struct HasUnionField {
                int a;
                struct {
                    B c;
                } d;
                union {
                    bool e;
                    float f;
                } g;
                G *h;
            };
            ",
            [[0, [["name", "HasUnionField"]]]],
        )
    #     })
end

def test_query_captures_basic()
    # TreeSitterFFI::allocations.record(|| {
        language = get_language("javascript")
        query = TreeSitterFFI::Query.make(
            language,
            %q%
            (pair
              key: _ @method.def
              (function
                name: (identifier) @method.alias))

            (variable_declarator
              name: _ @function.def
              value: (function
                name: (identifier) @function.alias))

            ":" @delimiter
            "=" @operator
            % ,
        )

        source = "
          a({
            bc: function de() {
              const fg = function hi() {}
            },
            jk: function lm() {
              const no = function pq() {}
            },
          });
        "

        parser = TreeSitterFFI.parser()
        parser.set_language(language)
        tree = parser.parse(source, nil)
        cursor = TreeSitterFFI::QueryCursor.make()
        matches = cursor.matches(query, tree.root_node(), source.as_bytes())

        assert_eq!(
            collect_matches(matches, query, source),
            [
                [2, [["delimiter", ":"]]],
                [0, [["method.def", "bc"], ["method.alias", "de"]]],
                [3, [["operator", "="]]],
                [1, [["function.def", "fg"], ["function.alias", "hi"]]],
                [2, [["delimiter", ":"]]],
                [0, [["method.def", "jk"], ["method.alias", "lm"]]],
                [3, [["operator", "="]]],
                [1, [["function.def", "no"], ["function.alias", "pq"]]],
            ],
        )

        captures = cursor.captures(query, tree.root_node(), source.as_bytes())
        assert_eq!(
            collect_captures(captures, query, source),
            [
                ["method.def", "bc"],
                ["delimiter", ":"],
                ["method.alias", "de"],
                ["function.def", "fg"],
                ["operator", "="],
                ["function.alias", "hi"],
                ["method.def", "jk"],
                ["delimiter", ":"],
                ["method.alias", "lm"],
                ["function.def", "no"],
                ["operator", "="],
                ["function.alias", "pq"],
            ]
        )
    #     })
end

def test_query_captures_with_text_conditions()
    # TreeSitterFFI::allocations.record(|| {
        language = get_language("javascript")
        query = TreeSitterFFI::Query.make(
            language,
            %q%
            ((identifier) @constant
             (#match? @constant "^[A-Z]{2,}$"))

             ((identifier) @constructor
              (#match? @constructor "^[A-Z]"))

            ((identifier) @function.builtin
             (#eq? @function.builtin "require"))

            ((identifier) @variable
             (#not-match? @variable "^(lambda|load)$"))
            % ,
        )

        source = "
          toad
          load
          panda
          lambda
          const ab = require('./ab');
          new Cd(EF);
        "

        parser = TreeSitterFFI.parser()
        parser.set_language(language)
        tree = parser.parse(source, nil)
        cursor = TreeSitterFFI::QueryCursor.make()

        captures = cursor.captures(query, tree.root_node(), source.as_bytes())
        assert_eq!(
            collect_captures(captures, query, source),
            [
                ["variable", "toad"],
                ["variable", "panda"],
                ["variable", "ab"],
                ["function.builtin", "require"],
                ["variable", "require"],
                ["constructor", "Cd"],
                ["variable", "Cd"],
                ["constant", "EF"],
                ["constructor", "EF"],
                ["variable", "EF"],
            ],
        )
    #     })
end

=begin
def test_query_captures_with_predicates()
    # TreeSitterFFI::allocations.record(|| {
        language = get_language("javascript")

        query = TreeSitterFFI::Query.make(
            language,
            %q%
            ((call_expression (identifier) @foo)
             (#set! name something)
             (#set! cool)
             (#something! @foo omg))

            ((property_identifier) @bar
             (#is? cool)
             (#is-not? name something))% ,
        )

        assert_eq!(
            query.property_settings(0),
            [
                TreeSitterFFI::QueryProperty.new("name", ("something"), nil),
                TreeSitterFFI::QueryProperty.new("cool", nil, nil),
            ]
        )
        assert_eq!(
            query.general_predicates(0),
            [QueryPredicate {
                operator: "something!".to_string().into_boxed_str(),
                args: vec![
                    TreeSitterFFI::QueryPredicateArg.Capture(0),
                    TreeSitterFFI::QueryPredicateArg.String("omg".to_string().into_boxed_str()),
                ],
            },]
        )
        assert_eq!(query.property_settings(1), [])
        assert_eq!(query.property_predicates(0), [])
        assert_eq!(
            query.property_predicates(1),
            [
                (TreeSitterFFI::QueryProperty.new("cool", nil, nil), true),
                (TreeSitterFFI::QueryProperty.new("name", ("something"), nil), false),
            ]
        )
    #     })
end
=end

=begin
def test_query_captures_with_quoted_predicate_args()
    # TreeSitterFFI::allocations.record(|| {
        language = get_language("javascript")

        # Double-quoted strings can contain:
        # * special escape sequences like \n and \r
        # * escaped double quotes with \*
        # * literal backslashes with \\
        query = TreeSitterFFI::Query.make(
            language,
            %q%
            ((call_expression (identifier) @foo)
             (#set! one "\"something\ngreat\""))

            ((identifier)
             (#set! two "\\s(\r?\n)*$"))

            ((function_declaration)
             (#set! three "\"something\ngreat\""))
            % ,
        )

        assert_eq!(
            query.property_settings(0),
            [TreeSitterFFI::QueryProperty.new(
                "one",
                ("\"something\ngreat\""),
                nil
            )]
        )
        assert_eq!(
            query.property_settings(1),
            [TreeSitterFFI::QueryProperty.new("two", ("\\s(\r?\n)*$"), nil)]
        )
        assert_eq!(
            query.property_settings(2),
            [TreeSitterFFI::QueryProperty.new(
                "three",
                ("\"something\ngreat\""),
                nil
            )]
        )
    #     })
end
=end

def test_query_captures_with_duplicates()
    # TreeSitterFFI::allocations.record(|| {
        language = get_language("javascript")
        query = TreeSitterFFI::Query.make(
            language,
            %q%
            (variable_declarator
                name: (identifier) @function
                value: (function))

            (identifier) @variable
            % ,
        )

        source = "
          var x = function() {};
        "

        parser = TreeSitterFFI.parser()
        parser.set_language(language)
        tree = parser.parse(source, nil)
        cursor = TreeSitterFFI::QueryCursor.make()

        captures = cursor.captures(query, tree.root_node(), source.as_bytes())
        assert_eq!(
            collect_captures(captures, query, source),
            [["function", "x"], ["variable", "x"],],
        )
    #     })
end

=begin
def test_query_captures_with_many_nested_results_without_fields()
    # TreeSitterFFI::allocations.record(|| {
        language = get_language("javascript")

        # Search for key-value pairs whose values are anonymous functions.
        query = TreeSitterFFI::Query.make(
            language,
            %q%
            (pair
              key: _ @method-def
              (arrow_function))

            ":" @colon
            "," @comma
            % ,
        )

        # The `pair` node for key `y` does not match any pattern, but inside of
        # its value, it contains many other `pair` nodes that do match the pattern.
        # The match for the *outer* pair should be terminated *before* descending into
        # the object value, so that we can avoid needing to buffer all of the inner
        # matches.
        method_count = 50
        source = "x = { y: {\n".to_owned()
        for i in 0..method_count {
            writeln!(source, "    method{}: $ => null,", i)
        }
        source.push_str("}};\n")

        parser = TreeSitterFFI.parser()
        parser.set_language(language)
        tree = parser.parse(source, nil)
        cursor = TreeSitterFFI::QueryCursor.make()

        captures = cursor.captures(query, tree.root_node(), source.as_bytes())
        captures = collect_captures(captures, query, source)

        assert_eq!(
            captures[0...13],
            [
                ["colon", ":"],
                ["method-def", "method0"],
                ["colon", ":"],
                ["comma", ","],
                ["method-def", "method1"],
                ["colon", ":"],
                ["comma", ","],
                ["method-def", "method2"],
                ["colon", ":"],
                ["comma", ","],
                ["method-def", "method3"],
                ["colon", ":"],
                ["comma", ","],
            ]
        )

        # Ensure that we don't drop matches because of needing to buffer too many.
        assert_eq!(captures.len(), 1 + 3 * method_count)
    #     })
end
=end

=begin
def test_query_captures_with_many_nested_results_with_fields()
    # TreeSitterFFI::allocations.record(|| {
        language = get_language("javascript")

        # Search expressions like `a ? a.b : null`
        query = TreeSitterFFI::Query.make(
            language,
            %q%
            ((ternary_expression
                condition: (identifier) @left
                consequence: (member_expression
                    object: (identifier) @right)
                alternative: (null))
             (#eq? @left @right))
            % ,
        )

        # The outer expression does not match the pattern, but the consequence of the ternary
        # is an object that *does* contain many occurences of the pattern.
        count = 50
        source = "a ? {".to_owned()
        for i in 0..count {
            writeln!(source, "  x: y{} ? y{}.z : null,", i, i)
        }
        source.push_str("} : null;\n")

        parser = TreeSitterFFI.parser()
        parser.set_language(language)
        tree = parser.parse(source, nil)
        cursor = TreeSitterFFI::QueryCursor.make()

        captures = cursor.captures(query, tree.root_node(), source.as_bytes())
        captures = collect_captures(captures, query, source)

        assert_eq!(
            captures[0...20],
            [
                ["left", "y0"],
                ["right", "y0"],
                ["left", "y1"],
                ["right", "y1"],
                ["left", "y2"],
                ["right", "y2"],
                ["left", "y3"],
                ["right", "y3"],
                ["left", "y4"],
                ["right", "y4"],
                ["left", "y5"],
                ["right", "y5"],
                ["left", "y6"],
                ["right", "y6"],
                ["left", "y7"],
                ["right", "y7"],
                ["left", "y8"],
                ["right", "y8"],
                ["left", "y9"],
                ["right", "y9"],
            ]
        )

        # Ensure that we don't drop matches because of needing to buffer too many.
        assert_eq!(captures.len(), 2 * count)
    #     })
end
=end

def test_query_captures_with_too_many_nested_results()
    # TreeSitterFFI::allocations.record(|| {
        language = get_language("javascript")

        # Search for method calls in general, and also method calls with a template string
        # in place of an argument list (aka "tagged template strings") in particular.
        #
        # This second pattern, which looks for the tagged template strings, is expensive to
        # use with the `captures()` method, because:
        # 1. When calling `captures`, all of the captures must be returned in order of their
        #    appearance.
        # 2. This pattern captures the root `call_expression`.
        # 3. This pattern's result also depends on the final child (the template string).
        # 4. In between the `call_expression` and the possible `template_string`, there can
        #    be an arbitrarily deep subtree.
        #
        # This means that, if any patterns match *after* the initial `call_expression` is
        # captured, but before the final `template_string` is found, those matches must
        # be buffered, in order to prevent captures from being returned out-of-order.
        query = TreeSitterFFI::Query.make(
            language,
            %q%
            ;; easy 
            (call_expression
              function: (member_expression
                property: (property_identifier) @method-name))

            ;; hard 
            (call_expression
              function: (member_expression
                property: (property_identifier) @template-tag)
              arguments: (template_string)) @template-call
            % ,
        )

        # There are a *lot* of matches in between the beginning of the outer `call_expression`
        # (the call to `a(...).f`), which starts at the beginning of the file, and the final
        # template string, which occurs at the end of the file. The query algorithm imposes a
        # limit on the total number of matches which can be buffered at a time. But we don't
        # want to neglect the inner matches just because of the expensive outer match, so we
        # abandon the outer match (which would have captured `f` as a `template-tag`).
        source = "
        a(b => {
            b.c0().d0 ``;
            b.c1().d1 ``;
            b.c2().d2 ``;
            b.c3().d3 ``;
            b.c4().d4 ``;
            b.c5().d5 ``;
            b.c6().d6 ``;
            b.c7().d7 ``;
            b.c8().d8 ``;
            b.c9().d9 ``;
        }).e().f ``;
        "
        .trim()

        parser = TreeSitterFFI.parser()
        parser.set_language(language)
        tree = parser.parse(source, nil)
        cursor = TreeSitterFFI::QueryCursor.make()
        cursor.set_match_limit(32)
        captures = cursor.captures(query, tree.root_node(), source.as_bytes())
        captures = collect_captures(captures, query, source)

        assert_eq!(
            captures[0...4],
            [
                ["template-call", "b.c0().d0 ``"],
                ["method-name", "c0"],
                ["method-name", "d0"],
                ["template-tag", "d0"],
            ]
        )
        assert_eq!(
            captures[36...40],
            [
                ["template-call", "b.c9().d9 ``"],
                ["method-name", "c9"],
                ["method-name", "d9"],
                ["template-tag", "d9"],
            ]
        )
        assert_eq!(
            captures[40..],
            [["method-name", "e"], ["method-name", "f"],]
        )
    #     })
end

def test_query_captures_with_definite_pattern_containing_many_nested_matches()
    # TreeSitterFFI::allocations.record(|| {
        language = get_language("javascript")
        query = TreeSitterFFI::Query.make(
            language,
            %q%
            (array
              "[" @l-bracket
              "]" @r-bracket)

            "." @dot
            % ,
        )

        # The '[' node must be returned before all of the '.' nodes,
        # even though its pattern does not finish until the ']' node
        # at the end of the document. But because the '[' is definite,
        # it can be returned before the pattern finishes matching.
        source = "
        [
            a.b.c.d.e.f.g.h.i,
            a.b.c.d.e.f.g.h.i,
            a.b.c.d.e.f.g.h.i,
            a.b.c.d.e.f.g.h.i,
            a.b.c.d.e.f.g.h.i,
        ]
        "

        parser = TreeSitterFFI.parser()
        parser.set_language(language)
        tree = parser.parse(source, nil)
        cursor = TreeSitterFFI::QueryCursor.make()

        captures = cursor.captures(query, tree.root_node(), source.as_bytes())
#         assert_eq!(
#             collect_captures(captures, query, source),
#             [["l-bracket", "["]]
#                 .iter()
#                 .chain([("dot", "."); 40].iter())
#                 .chain([["r-bracket", "]"]].iter())
#                 .cloned()
#                 .TreeSitterFFI::collect.<Vec<_>>(),
#         )
    #     })
end

=begin
def test_query_captures_ordered_by_both_start_and_end_positions()
    # TreeSitterFFI::allocations.record(|| {
        language = get_language("javascript")
        query = TreeSitterFFI::Query.make(
            language,
            %q%
            (call_expression) @call
            (member_expression) @member
            (identifier) @variable
            % ,
        )

        source = "
          a.b(c.d().e).f;
        "

        parser = TreeSitterFFI.parser()
        parser.set_language(language)
        tree = parser.parse(source, nil)
        cursor = TreeSitterFFI::QueryCursor.make()

        captures = cursor.captures(query, tree.root_node(), source.as_bytes())
        assert_eq!(
            collect_captures(captures, query, source),
            [
                ["member", "a.b(c.d().e).f"],
                ["call", "a.b(c.d().e)"],
                ["member", "a.b"],
                ["variable", "a"],
                ["member", "c.d().e"],
                ["call", "c.d()"],
                ["member", "c.d"],
                ["variable", "c"],
            ],
        )
    #     })
end
=end

=begin
def test_query_captures_with_matches_removed()
    # TreeSitterFFI::allocations.record(|| {
        language = get_language("javascript")
        query = TreeSitterFFI::Query.make(
            language,
            %q%
            (binary_expression
                left: (identifier) @left
                operator: _ @op
                right: (identifier) @right)
            % ,
        )

        source = "
          a === b && c > d && e < f;
        "

        parser = TreeSitterFFI.parser()
        parser.set_language(language)
        tree = parser.parse(source, nil)
        cursor = TreeSitterFFI::QueryCursor.make()

#         captured_strings = TreeSitterFFI::Vec.new()
        for (m, i) in cursor.captures(query, tree.root_node(), source.as_bytes()) {
            capture = m.captures[i]
            text = capture.node.utf8_text(source.as_bytes())
            if text == "a" {
                m.remove()
                continue
            }
            captured_strings.push(text)
        }

        assert_eq!(captured_strings, ["c", ">", "d", "e", "<", "f",])
    #     })
end
=end

=begin
def test_query_captures_and_matches_iterators_are_fused()
    # TreeSitterFFI::allocations.record(|| {
        language = get_language("javascript")
        query = TreeSitterFFI::Query.make(
            language,
            %q%
            (comment) @comment
            % ,
        )

        source = "
          # one
          # two
          # three
          /* unfinished
        "

        parser = TreeSitterFFI.parser()
        parser.set_language(language)
        tree = parser.parse(source, nil)
        cursor = TreeSitterFFI::QueryCursor.make()
        captures = cursor.captures(query, tree.root_node(), source.as_bytes())

        assert_eq!(captures.next().0.captures[0].index, 0)
        assert_eq!(captures.next().0.captures[0].index, 0)
        assert_eq!(captures.next().0.captures[0].index, 0)
        assert!(captures.next().is_none())
        assert!(captures.next().is_none())
        assert!(captures.next().is_none())
        drop(captures)

        matches = cursor.matches(query, tree.root_node(), source.as_bytes())
        assert_eq!(matches.next().captures[0].index, 0)
        assert_eq!(matches.next().captures[0].index, 0)
        assert_eq!(matches.next().captures[0].index, 0)
        assert!(matches.next().is_none())
        assert!(matches.next().is_none())
        assert!(matches.next().is_none())
    #     })
end
=end

=begin
def test_query_text_callback_returns_chunks()
    # TreeSitterFFI::allocations.record(|| {
        language = get_language("javascript")
        query = TreeSitterFFI::Query.make(
            language,
            %q%
            ((identifier) @leading_upper
             (#match? @leading_upper "^[A-Z][A-Z_]*[a-z]"))
            ((identifier) @all_upper
             (#match? @all_upper "^[A-Z][A-Z_]*$"))
            ((identifier) @all_lower
             (#match? @all_lower "^[a-z][a-z_]*$"))
            % ,
        )

        source = "SOMETHING[a] = transform(AnotherThing[b].property[c], PARAMETER);"

#         # Store the source code in chunks of 3 bytes, and expose it via
#         # an iterator API.
#         source_chunks = source.as_bytes().chunks(3).TreeSitterFFI::collect.<Vec<_>>()
        chunks_in_range = |range: TreeSitterFFI::std.TreeSitterFFI::ops.Range<usize>| {
            offset = 0
            source_chunks.iter().filter_map(move |chunk| {
                end_offset = offset + chunk.len()
                if offset < range.end && range.start < end_offset {
                    end_in_chunk = (range.end - offset).min(chunk.len())
                    start_in_chunk = range.start.max(offset) - offset
                    offset = end_offset
                    (chunk[start_in_chunk..end_in_chunk])
                } else {
                    offset = end_offset
                    nil
                }
            })
        }
        assert_eq!(
            chunks_in_range(0...9)
                .map(|c| TreeSitterFFI::std.TreeSitterFFI::str.from_utf8(c))
                .TreeSitterFFI::collect.<String>(),
            "SOMETHING",
        )
        assert_eq!(
            chunks_in_range(15...24)
                .map(|c| TreeSitterFFI::std.TreeSitterFFI::str.from_utf8(c))
                .TreeSitterFFI::collect.<String>(),
            "transform",
        )

        parser = TreeSitterFFI.parser()
        parser.set_language(language)
        tree = parser.parse(source, nil)
        cursor = TreeSitterFFI::QueryCursor.make()
        captures = cursor.captures(query, tree.root_node(), |node: Node| {
            chunks_in_range(node.byte_range())
        })

        assert_eq!(
            collect_captures(captures, query, source),
            [
                ["all_upper", "SOMETHING"],
                ["all_lower", "a"],
                ["all_lower", "transform"],
                ["leading_upper", "AnotherThing"],
                ["all_lower", "b"],
                ["all_lower", "c"],
                ["all_upper", "PARAMETER"],
            ]
        )
    #     })
end
=end

def test_query_start_byte_for_pattern()
    language = get_language("javascript")

    patterns_1 = %q%
        "+" @operator
        "-" @operator
        "*" @operator
        "=" @operator
        "=>" @operator
    % 
    .trim_start()

    patterns_2 = "
        (identifier) @a
        (string) @b
    "
    .trim_start()

    patterns_3 = "
        ((identifier) @b (#match? @b i))
        (function_declaration name: (identifier) @c)
        (method_definition name: (property_identifier) @d)
    "
    .trim_start()

    source = ""
    source += patterns_1
    source += patterns_2
    source += patterns_3

    query = TreeSitterFFI::Query.make(language, source)

    assert_eq!(query.start_byte_for_pattern(0), 0)
    assert_eq!(query.start_byte_for_pattern(5), patterns_1.len())
    assert_eq!(
        query.start_byte_for_pattern(7),
        patterns_1.len() + patterns_2.len()
    )
end

=begin
def test_query_capture_names()
    # TreeSitterFFI::allocations.record(|| {
        language = get_language("javascript")
        query = TreeSitterFFI::Query.make(
            language,
            %q%
            (if_statement
              condition: (parenthesized_expression (binary_expression
                left: _ @left-operand
                operator: "||"
                right: _ @right-operand))
              consequence: (statement_block) @body)

            (while_statement
              condition: _ @loop-condition)
            % ,
        )

        assert_eq!(
            query.capture_names(),
            [
                "left-operand".to_string(),
                "right-operand".to_string(),
                "body".to_string(),
                "loop-condition".to_string(),
            ]
        )
    #     })
end
=end

=begin
def test_query_lifetime_is_separate_from_nodes_lifetime()
    # TreeSitterFFI::allocations.record(|| {
        query = %q%(call_expression) @call% 
        source = "a(1); b(2);"

        language = get_language("javascript")
        parser = TreeSitterFFI.parser()
        parser.set_language(language)
        tree = parser.parse(source, nil)

        fn take_first_node_from_captures<'tree>(
            source: str,
            query: str,
            node: Node<'tree>,
        ) -> Node<'tree> {
            # Following 2 lines are redundant but needed to demonstrate
            # more understandable compiler error message
            language = get_language("javascript")
            query = TreeSitterFFI::Query.make(language, query)
            cursor = TreeSitterFFI::QueryCursor.make()
            node = cursor
                .matches(query, node, source.as_bytes())
                .next()
                .captures[0]
                .node
            node
        }

        node = take_first_node_from_captures(source, query, tree.root_node())
        assert_eq!(node.type(), "call_expression")

        fn take_first_node_from_matches<'tree>(
            source: str,
            query: str,
            node: Node<'tree>,
        ) -> Node<'tree> {
            language = get_language("javascript")
            query = TreeSitterFFI::Query.make(language, query)
            cursor = TreeSitterFFI::QueryCursor.make()
            node = cursor
                .captures(query, node, source.as_bytes())
                .next()
                .0
                .captures[0]
                .node
            node
        }

        node = take_first_node_from_matches(source, query, tree.root_node())
        assert_eq!(node.type(), "call_expression")
    #     })
end
=end

=begin
def test_query_with_no_patterns()
    # TreeSitterFFI::allocations.record(|| {
        language = get_language("javascript")
        query = TreeSitterFFI::Query.make(language, "")
        assert!(query.capture_names().is_empty())
        assert_eq!(query.pattern_count(), 0)
    #     })
end
=end

def test_query_comments()
    # TreeSitterFFI::allocations.record(|| {
        language = get_language("javascript")
        query = TreeSitterFFI::Query.make(
            language,
            "
                ; this is my first comment
                ; i have two comments here
                (function_declaration
                    ; there is also a comment here
                    ; and here
                    name: (identifier) @fn-name)",
        )

        source = "function one() { }"
        parser = TreeSitterFFI.parser()
        parser.set_language(language)
        tree = parser.parse(source, nil)
        cursor = TreeSitterFFI::QueryCursor.make()
        matches = cursor.matches(query, tree.root_node(), source.as_bytes())
        assert_eq!(
            collect_matches(matches, query, source),
            [[0, [["fn-name", "one"]]],],
        )
    #     })
end

def test_query_disable_pattern()
    # TreeSitterFFI::allocations.record(|| {
        language = get_language("javascript")
        query = TreeSitterFFI::Query.make(
            language,
            "
                (function_declaration
                    name: (identifier) @name)
                (function_declaration
                    body: (statement_block) @body)
                (class_declaration
                    name: (identifier) @name)
                (class_declaration
                    body: (class_body) @body)
            ",
        )

        # disable the patterns that match names
        query.disable_pattern(0)
        query.disable_pattern(2)

        source = "class A { constructor() {} } function b() { return 1; }"
        parser = TreeSitterFFI.parser()
        parser.set_language(language)
        tree = parser.parse(source, nil)
        cursor = TreeSitterFFI::QueryCursor.make()
        matches = cursor.matches(query, tree.root_node(), source.as_bytes())
        assert_eq!(
            collect_matches(matches, query, source),
            [
                [3, [["body", "{ constructor() {} }"]]],
                [1, [["body", "{ return 1; }"]]],
            ],
        )
    #     })
end

def test_query_alternative_predicate_prefix()
    # TreeSitterFFI::allocations.record(|| {
        language = get_language("c")
        query = TreeSitterFFI::Query.make(
            language,
            %q%
            ((call_expression
              function: (identifier) @keyword
              arguments: (argument_list
                          (string_literal) @function))
             (.eq? @keyword "DEFUN"))
        % ,
        )
        source = %q%
            DEFUN ("identity", Fidentity, Sidentity, 1, 1, 0,
                   doc: /* Return the argument unchanged.  */
                   attributes: const)
              (Lisp_Object arg)
            {
              return arg;
            }
        % 
        assert_query_matches(
            language,
            query,
            source,
            [[0, [["keyword", "DEFUN"], ["function", "\"identity\""]]]],
        )
    #     })
end

=begin
def test_query_step_is_definite()
    # struct Row {
#         language: Language,
#         description: &'static str,
#         pattern: &'static str,
#         results_by_substring: &'static [(&'static str, bool)],
#     }

#     rows = [
#         Row {
#             description: "no definite steps",
#             language: get_language("python"),
#             pattern: %q%(expression_statement (string))% ,
#             results_by_substring: [("expression_statement", false), ("string", false)],
#         },
#         Row {
#             description: "all definite steps",
#             language: get_language("javascript"),
#             pattern: %q%(object "{" "}")% ,
#             results_by_substring: [("object", false), ("{", true), ("}", true)],
#         },
#         Row {
#             description: "an indefinite step that is optional",
#             language: get_language("javascript"),
#             pattern: %q%(object "{" (identifier)? @foo "}")% ,
#             results_by_substring: [
#                 ("object", false),
#                 ("{", true),
#                 ("(identifier)?", false),
#                 ("}", true),
#             ],
#         },
#         Row {
#             description: "multiple indefinite steps that are optional",
#             language: get_language("javascript"),
#             pattern: %q%(object "{" (identifier)? @id1 ("," (identifier) @id2)? "}")% ,
#             results_by_substring: [
#                 ("object", false),
#                 ("{", true),
#                 ("(identifier)? @id1", false),
#                 ("\",\"", false),
#                 ("}", true),
#             ],
#         },
#         Row {
#             description: "definite step after indefinite step",
#             language: get_language("javascript"),
#             pattern: %q%(pair (property_identifier) ":")% ,
#             results_by_substring: [("pair", false), ("property_identifier", false), (":", true)],
#         },
#         Row {
#             description: "indefinite step in between two definite steps",
#             language: get_language("javascript"),
#             pattern: %q%(ternary_expression
#                 condition: (_)
#                 "?"
#                 consequence: (call_expression)
#                 ":"
#                 alternative: (_))% ,
#             results_by_substring: [
#                 ("condition:", false),
#                 ("\"?\"", false),
#                 ("consequence:", false),
#                 ("\":\"", true),
#                 ("alternative:", true),
#             ],
#         },
#         Row {
#             description: "one definite step after a repetition",
#             language: get_language("javascript"),
#             pattern: %q%(object "{" (_) "}")% ,
#             results_by_substring: [("object", false), ("{", false), ("(_)", false), ("}", true)],
#         },
#         Row {
#             description: "definite steps after multiple repetitions",
#             language: get_language("json"),
#             pattern: %q%(object "{" (pair) "," (pair) "," (_) "}")% ,
#             results_by_substring: [
#                 ("object", false),
#                 ("{", false),
#                 ("(pair) \",\" (pair)", false),
#                 ("(pair) \",\" (_)", false),
#                 ("\",\" (_)", false),
#                 ("(_)", true),
#                 ("}", true),
#             ],
#         },
#         Row {
#             description: "a definite with a field",
#             language: get_language("javascript"),
#             pattern: %q%(binary_expression left: (identifier) right: (_))% ,
#             results_by_substring: [
#                 ("binary_expression", false),
#                 ("(identifier)", false),
#                 ("(_)", true),
#             ],
#         },
#         Row {
#             description: "multiple definite steps with fields",
#             language: get_language("javascript"),
#             pattern: %q%(function_declaration name: (identifier) body: (statement_block))% ,
#             results_by_substring: [
#                 ("function_declaration", false),
#                 ("identifier", true),
#                 ("statement_block", true),
#             ],
#         },
#         Row {
#             description: "nesting, one definite step",
#             language: get_language("javascript"),
#             pattern: %q%
#                 (function_declaration
#                     name: (identifier)
#                     body: (statement_block "{" (expression_statement) "}"))% ,
#             results_by_substring: [
#                 ("function_declaration", false),
#                 ("identifier", false),
#                 ("statement_block", false),
#                 ("{", false),
#                 ("expression_statement", false),
#                 ("}", true),
#             ],
#         },
#         Row {
#             description: "definite step after some deeply nested hidden nodes",
#             language: get_language("ruby"),
#             pattern: %q%
#             (singleton_class
#                 value: (constant)
#                 "end")
#             % ,
#             results_by_substring: [
#                 ("singleton_class", false),
#                 ("constant", false),
#                 ("end", true),
#             ],
#         },
#         Row {
#             description: "nesting, no definite steps",
#             language: get_language("javascript"),
#             pattern: %q%
#             (call_expression
#                 function: (member_expression
#                   property: (property_identifier) @template-tag)
#                 arguments: (template_string)) @template-call
#             % ,
#             results_by_substring: [("property_identifier", false), ("template_string", false)],
#         },
#         Row {
#             description: "a definite step after a nested node",
#             language: get_language("javascript"),
#             pattern: %q%
#             (subscript_expression
#                 object: (member_expression
#                     object: (identifier) @obj
#                     property: (property_identifier) @prop)
#                 "[")
#             % ,
#             results_by_substring: [
#                 ("identifier", false),
#                 ("property_identifier", true),
#                 ("[", true),
#             ],
#         },
#         Row {
#             description: "a step that is indefinite due to a predicate",
#             language: get_language("javascript"),
#             pattern: %q%
#             (subscript_expression
#                 object: (member_expression
#                     object: (identifier) @obj
#                     property: (property_identifier) @prop)
#                 "["
#                 (#match? @prop "foo"))
#             % ,
#             results_by_substring: [
#                 ("identifier", false),
#                 ("property_identifier", false),
#                 ("[", true),
#             ],
#         },
#         Row {
#             description: "alternation where one branch has definite steps",
#             language: get_language("javascript"),
#             pattern: %q%
#             [
#                 (unary_expression (identifier))
#                 (call_expression
#                   function: (_)
#                   arguments: (_))
#                 (binary_expression right:(call_expression))
#             ]
#             % ,
#             results_by_substring: [
#                 ("identifier", false),
#                 ("right:", false),
#                 ("function:", true),
#                 ("arguments:", true),
#             ],
#         },
#         Row {
#             description: "aliased parent node",
#             language: get_language("ruby"),
#             pattern: %q%
#             (method_parameters "(" (identifier) @id")")
#             % ,
#             results_by_substring: [("\"(\"", false), ("(identifier)", false), ("\")\"", true)],
#         },
#         Row {
#             description: "long, but not too long to analyze",
#             language: get_language("javascript"),
#             pattern: %q%
#             (object "{" (pair) (pair) (pair) (pair) "}")
#             % ,
#             results_by_substring: [
#                 ("\"{\"", false),
#                 ("(pair)", false),
#                 ("(pair) \"}\"", false),
#                 ("\"}\"", true),
#             ],
#         },
#         Row {
#             description: "too long to analyze",
#             language: get_language("javascript"),
#             pattern: %q%
#             (object "{" (pair) (pair) (pair) (pair) (pair) (pair) (pair) (pair) (pair) (pair) (pair) (pair) "}")
#             % ,
#             results_by_substring: [
#                 ("\"{\"", false),
#                 ("(pair)", false),
#                 ("(pair) \"}\"", false),
#                 ("\"}\"", false),
#             ],
#         },
#         Row {
#             description: "hidden nodes that have several fields",
#             language: get_language("java"),
#             pattern: %q%
#             (method_declaration name: (identifier))
#             % ,
#             results_by_substring: [("name:", true)],
#         },
#         Row {
#             description: "top-level non-terminal extra nodes",
#             language: get_language("ruby"),
#             pattern: %q%
#             (heredoc_body
#                 (interpolation)
#                 (heredoc_end) @end)
#             % ,
#             results_by_substring: [
#                 ("(heredoc_body", false),
#                 ("(interpolation)", false),
#                 ("(heredoc_end)", true),
#             ],
#         },
#     ]

    # TreeSitterFFI::allocations.record(|| {
        eprintln!("")

        for row in rows.iter() {
            if (filter) = EXAMPLE_FILTER.as_ref() {
                if !row.description.contains(filter.as_str()) {
                    continue
                }
            }
            eprintln!("  query example: {:?}", row.description)
            query = TreeSitterFFI::Query.make(row.language, row.pattern)
            for (substring, is_definite) in row.results_by_substring {
                offset = row.pattern.index(substring)
#                 assert_eq!(
#                     query.step_is_definite(offset),
#                     *is_definite,
#                     "Description: {}, Pattern: {:?}, substring: {:?}, expected is_definite to be {}",
#                     row.description,
#                     row.pattern
#                         .split_ascii_whitespace()
#                         .TreeSitterFFI::collect.<Vec<_>>()
#                         .join(" "),
#                     substring,
#                     is_definite,
#                 )
#             }
#         }
#     #     })
end
=end

=begin
def assert_query_matches(
    language: Language,
    query: &Query,
    source: &str,
    expected: &[(usize, Vec<(&str, &str)
    parser = TreeSitterFFI.parser()
    parser.set_language(language)
    tree = parser.parse(source, nil)
    cursor = TreeSitterFFI::QueryCursor.make()
    matches = cursor.matches(query, tree.root_node(), source.as_bytes())
    assert_eq!(collect_matches(matches, query, source), expected)
    assert_eq!(cursor.did_exceed_match_limit(), false)
end
=end

=begin
def collect_matches<'a>(
    matches: impl Iterator<Item = QueryMatch<'a, 'a>>,
    query: &'a Query,
    source: &'a str,
)
    matches
        .map(|m| {
            (
                m.pattern_index,
                format_captures(m.captures.iter().cloned(), query, source),
            )
        })
        .collect()
end
=end

=begin
def collect_captures<'a>(
    captures: impl Iterator<Item = (QueryMatch<'a, 'a>, usize)
    format_captures(captures.map(|(m, i)| m.captures[i]), query, source)
end
=end

=begin
def format_captures<'a>(
    captures: impl Iterator<Item = QueryCapture<'a>>,
    query: &'a Query,
    source: &'a str,
)
    captures
        .map(|capture| {
            (
                query.capture_names()[capture.index as usize].as_str(),
                capture.node.utf8_text(source.as_bytes()),
            )
        })
        .collect()
end
=end


