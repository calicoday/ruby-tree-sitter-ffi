# hacky hacky hacky -- generated by src/spec_gen.rb, then hand-tweaked

# this spec is only looking to check each ts_ call doesn't raise or crash and 
# returns the right type, given acceptable args

describe "node_spec.rb" do
	before do
	end
    
	it "type() # => String" do
		ret = node_0.type()
		ret.should_not == nil
		ret.is_a?(String).should == true
	end

	it "symbol() # => Integer" do
		ret = node_0.symbol()
		ret.should_not == nil
		ret.is_a?(Integer).should == true
	end

	it "start_byte() # => Integer" do
		ret = node_0.start_byte()
		ret.should_not == nil
		ret.is_a?(Integer).should == true
	end

	it "start_point() # => Point" do
		ret = node_0.start_point()
		ret.should_not == nil
		ret.is_a?(TreeSitterFFI::Point).should == true
	end

	it "end_byte() # => Integer" do
		ret = node_0.end_byte()
		ret.should_not == nil
		ret.is_a?(Integer).should == true
	end

	it "end_point() # => Point" do
		ret = node_0.end_point()
		ret.should_not == nil
		ret.is_a?(TreeSitterFFI::Point).should == true
	end

	it "string() # => Array" do
		ret = node_0.string()
		ret.should_not == nil
		ret.is_a?(Array).should == true
	end

	it "is_null() # => :bool" do
		ret = node_0.is_null()
		[true, false].include?(ret).should == true
	end

	it "is_named() # => :bool" do
		ret = node_0.is_named()
		[true, false].include?(ret).should == true
	end

	it "is_missing() # => :bool" do
		ret = node_0.is_missing()
		[true, false].include?(ret).should == true
	end

	it "is_extra() # => :bool" do
		ret = node_0.is_extra()
		[true, false].include?(ret).should == true
	end

	it "has_changes() # => :bool" do
		ret = node_0.has_changes()
		[true, false].include?(ret).should == true
	end

	it "has_error() # => :bool" do
		ret = node_0.has_error()
		[true, false].include?(ret).should == true
	end

	it "parent() # => Node" do
		ret = node_0.parent()
		ret.should_not == nil
		ret.is_a?(TreeSitterFFI::Node).should == true
	end

	it "child(Integer) # => Node" do
		ret = node_0.child(arg_1)
		ret.should_not == nil
		ret.is_a?(TreeSitterFFI::Node).should == true
	end

	it "child_count() # => Integer" do
		ret = node_0.child_count()
		ret.should_not == nil
		ret.is_a?(Integer).should == true
	end

	it "named_child(Integer) # => Node" do
		ret = node_0.named_child(arg_1)
		ret.should_not == nil
		ret.is_a?(TreeSitterFFI::Node).should == true
	end

	it "named_child_count() # => Integer" do
		ret = node_0.named_child_count()
		ret.should_not == nil
		ret.is_a?(Integer).should == true
	end

	it "child_by_field_name(String, Integer) # => Node" do
		ret = node_0.child_by_field_name(arg_1, arg_2)
		ret.should_not == nil
		ret.is_a?(TreeSitterFFI::Node).should == true
	end

	it "child_by_field_id(Integer) # => Node" do
		ret = node_0.child_by_field_id(arg_1)
		ret.should_not == nil
		ret.is_a?(TreeSitterFFI::Node).should == true
	end

	it "next_sibling() # => Node" do
		ret = node_0.next_sibling()
		ret.should_not == nil
		ret.is_a?(TreeSitterFFI::Node).should == true
	end

	it "prev_sibling() # => Node" do
		ret = node_0.prev_sibling()
		ret.should_not == nil
		ret.is_a?(TreeSitterFFI::Node).should == true
	end

	it "next_named_sibling() # => Node" do
		ret = node_0.next_named_sibling()
		ret.should_not == nil
		ret.is_a?(TreeSitterFFI::Node).should == true
	end

	it "prev_named_sibling() # => Node" do
		ret = node_0.prev_named_sibling()
		ret.should_not == nil
		ret.is_a?(TreeSitterFFI::Node).should == true
	end

	it "first_child_for_byte(Integer) # => Node" do
		ret = node_0.first_child_for_byte(arg_1)
		ret.should_not == nil
		ret.is_a?(TreeSitterFFI::Node).should == true
	end

	it "first_named_child_for_byte(Integer) # => Node" do
		ret = node_0.first_named_child_for_byte(arg_1)
		ret.should_not == nil
		ret.is_a?(TreeSitterFFI::Node).should == true
	end

	it "descendant_for_byte_range(Integer, Integer) # => Node" do
		ret = node_0.descendant_for_byte_range(arg_1, arg_2)
		ret.should_not == nil
		ret.is_a?(TreeSitterFFI::Node).should == true
	end

	it "descendant_for_point_range(Point, Point) # => Node" do
		ret = node_0.descendant_for_point_range(arg_1, arg_2)
		ret.should_not == nil
		ret.is_a?(TreeSitterFFI::Node).should == true
	end

	it "named_descendant_for_byte_range(Integer, Integer) # => Node" do
		ret = node_0.named_descendant_for_byte_range(arg_1, arg_2)
		ret.should_not == nil
		ret.is_a?(TreeSitterFFI::Node).should == true
	end

	it "named_descendant_for_point_range(Point, Point) # => Node" do
		ret = node_0.named_descendant_for_point_range(arg_1, arg_2)
		ret.should_not == nil
		ret.is_a?(TreeSitterFFI::Node).should == true
	end

	it "edit(InputEdit) # => :void" do
		ret = node_0.edit(arg_1)
		# ret void
	end

	it "eq(Node) # => :bool" do
		ret = node_0.eq(arg_1)
		[true, false].include?(ret).should == true
	end


end
