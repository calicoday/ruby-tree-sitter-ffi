# hacky hacky hacky -- generated by src/spec_gen.rb, then hand-tweaked

# this spec is only looking to check each ts_ call doesn't raise or crash and 
# returns the right type, given acceptable args

describe "ts_parser_spec.rb" do
	before do
	end
    
	it ":ts_parser_set_language, [Parser, Language], :bool" do
		ret = TreeSitterFFI.ts_parser_set_language(parser_0, arg_1)
		[true, false].include?(ret).should == true
	end

	it ":ts_parser_language, [Parser], Language" do
		ret = TreeSitterFFI.ts_parser_language(parser_0)
		ret.should_not == nil
		ret.is_a?(TreeSitterFFI::Language).should == true
	end

	it ":ts_parser_set_included_ranges, [Parser, Range.by_ref, :uint32], :bool" do
		ret = TreeSitterFFI.ts_parser_set_included_ranges(parser_0, arg_1, arg_2)
		[true, false].include?(ret).should == true
	end

	it ":ts_parser_included_ranges, [Parser, :uint32_p], :array_of_range" do
		ret = TreeSitterFFI.ts_parser_included_ranges(parser_0, arg_1)
		ret.should_not == nil
		ret.is_a?(TreeSitterFFI::Pointer).should == true
	end

	it ":ts_parser_parse, [Parser, Tree, Input.by_value], Tree" do
		ret = TreeSitterFFI.ts_parser_parse(parser_0, arg_1, arg_2)
		ret.should_not == nil
		ret.is_a?(TreeSitterFFI::Tree).should == true
	end

	it ":ts_parser_parse_string, [Parser, Tree, :string, :uint32], Tree" do
		ret = TreeSitterFFI.ts_parser_parse_string(parser_0, arg_1, arg_2, arg_3)
		ret.should_not == nil
		ret.is_a?(TreeSitterFFI::Tree).should == true
	end

	it ":ts_parser_parse_string_encoding, [Parser, Tree, :string, :uint32, InputEncoding], Tree" do
		ret = TreeSitterFFI.ts_parser_parse_string_encoding(parser_0, arg_1, arg_2, arg_3, arg_4)
		ret.should_not == nil
		ret.is_a?(TreeSitterFFI::Tree).should == true
	end

	it ":ts_parser_reset, [Parser], :void" do
		ret = TreeSitterFFI.ts_parser_reset(parser_0)
		# ret void
	end

	it ":ts_parser_set_timeout_micros, [Parser, :uint64], :void" do
		ret = TreeSitterFFI.ts_parser_set_timeout_micros(parser_0, arg_1)
		# ret void
	end

	it ":ts_parser_timeout_micros, [Parser], :uint64" do
		ret = TreeSitterFFI.ts_parser_timeout_micros(parser_0)
		ret.should_not == nil
		ret.is_a?(Integer).should == true
	end

	it ":ts_parser_set_cancellation_flag, [Parser, :size_p], :void" do
		ret = TreeSitterFFI.ts_parser_set_cancellation_flag(parser_0, arg_1)
		# ret void
	end

	it ":ts_parser_cancellation_flag, [Parser], :size_p" do
		ret = TreeSitterFFI.ts_parser_cancellation_flag(parser_0)
		ret.should_not == nil
		ret.is_a?(TreeSitterFFI::Pointer).should == true
	end

	it ":ts_parser_set_logger, [Parser, Logger.by_value], :void" do
		ret = TreeSitterFFI.ts_parser_set_logger(parser_0, arg_1)
		# ret void
	end

	it ":ts_parser_logger, [Parser], Logger.by_value" do
		ret = TreeSitterFFI.ts_parser_logger(parser_0)
		ret.should_not == nil
		ret.is_a?(TreeSitterFFI::Logger).should == true
	end

	it ":ts_parser_print_dot_graphs, [Parser, :file_descriptor], :void" do
		ret = TreeSitterFFI.ts_parser_print_dot_graphs(parser_0, arg_1)
		# ret void
	end


end
